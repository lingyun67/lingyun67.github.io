<!DOCTYPE html>
<html lang="zh-cn" dir="ltr" class="scroll-smooth" data-default-appearance="dark"
  data-auto-appearance="true"><head><script src="/about/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=about/livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  
  <meta http-equiv="content-language" content="zh-cn" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  
  <title>金旭亮C#编程课个人自学笔记 &middot; black raison detre</title>
  <meta name="title" content="金旭亮C#编程课个人自学笔记 &middot; black raison detre" />
  
  
  <meta name="keywords" content="编程, 笔记, " />
  
  
  <link rel="canonical" href="http://localhost:1313/about/posts/%E9%87%91%E6%97%AD%E4%BA%AEc%23%E7%BC%96%E7%A8%8B%E8%AF%BE%E4%B8%AA%E4%BA%BA%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/" />
  
  
  
  
  
  
  
  
  
  
  <link type="text/css" rel="stylesheet" href="/about/css/main.bundle.min.ac59a1b8eaafef739c129d12787ac29f6a420bcb348c7aeec8949a8d0b7d6c2023766c169d14b9031b751504eb3c976efe786fec135b340a49868acd8caa4127.css"
    integrity="sha512-rFmhuOqv73OcEp0SeHrCn2pCC8s0jHruyJSajQt9bCAjdmwWnRS5Axt1FQTrPJdu/nhv7BNbNApJhorNjKpBJw==" />
  
  
  <script type="text/javascript" src="/about/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js"
    integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj&#43;e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script>
  
  
  
  
  
  
  
  
  
  <script defer type="text/javascript" id="script-bundle" src="/about/js/main.bundle.min.b36dda9ec4ec11e967fd341e7d57b8c484ac7a39f8f329f7bcf7ce4812569de8607db866a086d4789956ac0b74967e251c9a566d94d469dd28b8787fed4f46f5.js"
    integrity="sha512-s23ansTsEeln/TQefVe4xISsejn48yn3vPfOSBJWnehgfbhmoIbUeJlWrAt0ln4lHJpWbZTUad0ouHh/7U9G9Q==" data-copy="" data-copied=""></script>
  
  
  <script src="/about/js/zoom.min.js"></script>
  
  
  
  <link rel="apple-touch-icon" sizes="180x180" href="/about/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/about/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/about/favicon-16x16.png" />
  <link rel="manifest" href="/about/site.webmanifest" />
  
  
  
  
  
  
  
  <meta property="og:url" content="http://localhost:1313/about/posts/%E9%87%91%E6%97%AD%E4%BA%AEc%23%E7%BC%96%E7%A8%8B%E8%AF%BE%E4%B8%AA%E4%BA%BA%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/">
  <meta property="og:site_name" content="black raison detre">
  <meta property="og:title" content="金旭亮C#编程课个人自学笔记">
  <meta property="og:description" content="前言 # .">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-02-28T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-02-28T00:00:00+00:00">
    <meta property="article:tag" content="编程">
    <meta property="article:tag" content="笔记">

  <meta name="twitter:card" content="summary"><meta name="twitter:title" content="金旭亮C#编程课个人自学笔记">
<meta name="twitter:description" content="前言 # .">

  
  <script type="application/ld+json">
  [{
    "@context": "https://schema.org",
    "@type": "Article",
    "articleSection": "Posts",
    "name": "金旭亮C#编程课个人自学笔记",
    "headline": "金旭亮C#编程课个人自学笔记",
    
    "abstract": "前言 # .",
    "inLanguage": "zh-cn",
    "url" : "http:\/\/localhost:1313\/about\/posts\/%E9%87%91%E6%97%AD%E4%BA%AEc%23%E7%BC%96%E7%A8%8B%E8%AF%BE%E4%B8%AA%E4%BA%BA%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0\/",
    "author" : {
      "@type": "Person",
      "name": "Kumo67"
    },
    "copyrightYear": "2023",
    "dateCreated": "2023-02-28T00:00:00\u002b00:00",
    "datePublished": "2023-02-28T00:00:00\u002b00:00",
    
    "dateModified": "2023-02-28T00:00:00\u002b00:00",
    
    "keywords": ["编程","笔记"],
    
    "mainEntityOfPage": "true",
    "wordCount": "5205"
  }]
  </script>


  
  
  <meta name="author" content="Kumo67" />
  
  
  
  <link href="https://twitter.com/burufugu" rel="me" />
  
  
  <link href="https://github.com/lingyun67" rel="me" />
  
  
  
  

<script src="/about/lib/jquery/jquery.slim.min.js" integrity=""></script>





















  
  


  
  
  <meta name="theme-color"/>
  
  
</head>
<body
  class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32">
  <div id="the-top" class="absolute flex self-center">
    <a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600"
      href="#main-content"><span
        class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>跳过正文</a>
  </div>
  
  
  <div style="padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px"
    class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start space-x-3">
    
    <div class="flex flex-1 items-center justify-between">
        <nav class="flex space-x-3">

            
            <a href="/about/" class="text-base font-medium text-gray-500 hover:text-gray-900">black raison detre</a>
            

        </nav>
        <nav class="hidden md:flex items-center space-x-5 md:ml-12 h-12">

            
            
            
  <a href=""  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="">
        学习笔记
    </p>
</a>


            
            
  <a href="/about/posts/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="">
        随记
    </p>
</a>


            
            

            


            
            <button id="search-button" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            


            
            
            <div
                class="ltr:mr-14 rtl:ml-14 flex items-center">
                <button id="appearance-switcher" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400">
                    <div class="flex items-center justify-center dark:hidden">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                    </div>
                    <div class="items-center justify-center hidden dark:flex">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                    </div>
                </button>
            </div>
            

        </nav>
        <div class="flex md:hidden items-center space-x-5 md:ml-12 h-12">

            <span></span>

            


            
            <button id="search-button-mobile" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            

            
            
            <button id="appearance-switcher-mobile" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400" style="margin-right:5px">
                <div class="flex items-center justify-center dark:hidden">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                </div>
                <div class="items-center justify-center hidden dark:flex">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                </div>
            </button>
            

        </div>
    </div>
    <div class="-my-2 -mr-2 md:hidden">

        <label id="menu-button" for="menu-controller" class="block">
            <input type="checkbox" id="menu-controller" class="hidden" />
            
            <div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400">
                

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"/></svg>

  </span>


            </div>
            <div id="menu-wrapper" style="padding-top:5px;"
                class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50">
                <ul
                    class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl">

                    <li>
                        <span
                            class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>

</span>
                    </li>

                    

                    
  <li class="mt-1">
    <a href=""  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="">
            学习笔记
        </p>
    </a>
</li>



                    

                    
  <li class="mt-1">
    <a href="/about/posts/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="">
            随记
        </p>
    </a>
</li>



                    

                </ul>
                
                

            </div>
        </label>
    </div>
</div>





  
  <div class="relative flex flex-col grow">
    <main id="main-content" class="grow">
      


<article>
  

  <header id="single_header" class="mt-5 max-w-prose">
    
    <h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
      金旭亮C#编程课个人自学笔记
    </h1>
    <div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden">
      





  
  







  





  



  













<div class="flex flex-row flex-wrap items-center">
  
  
  <time datetime="2023-02-28 00:00:00 &#43;0000 UTC">2023 February 28</time><span class="px-2 text-primary-500">&middot;</span><span>5205 字</span><span class="px-2 text-primary-500">&middot;</span><span title="预计阅读">25 分钟</span>
  

  
  
</div>





<div class="flex flex-row flex-wrap items-center">
  
  
  
  
  
  
  
  
  
  
  
  
  <span style="margin-top:0.5rem" class="mr-2" onclick="window.open(&#34;/about/tags/%E7%BC%96%E7%A8%8B/&#34;,'_self');">
    <span class="flex" style="cursor: pointer;">
  <span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">
    编程
  </span>
</span>
  </span>
  
  <span style="margin-top:0.5rem" class="mr-2" onclick="window.open(&#34;/about/tags/%E7%AC%94%E8%AE%B0/&#34;,'_self');">
    <span class="flex" style="cursor: pointer;">
  <span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">
    笔记
  </span>
</span>
  </span>
  
  
  
  
</div>



    </div>

    
    
    
    
    

    

    
      
      
        
        
<div class="flex author">
  
    
    
      
    
    
      
        
      
      <img class="!mt-0 !mb-0 h-24 w-24 rounded-full ltr:mr-4 rtl:ml-4" width="96" height="96"
      alt="Kumo67" src="/about/img/huangdou_logo_hu192ca31849736c9ab17c4ffc751ffaf8_26542_192x192_fill_box_center_3.png" />
    
  
  <div class="place-self-center">
    
    <div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">
      作者
    </div>
    <div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">
      Kumo67
    </div>
    
    
    <div class="text-sm text-neutral-700 dark:text-neutral-400">Don&rsquo;t cry over spilled milk.</div>
    
    <div class="text-2xl sm:text-lg">
  <div class="flex flex-wrap text-neutral-400 dark:text-neutral-500">
    
      
        <a
          class="px-1 hover:text-primary-700 dark:hover:text-primary-400"
          href="https://twitter.com/burufugu"
          target="_blank"
          aria-label="X-Twitter"
          rel="me noopener noreferrer"
          ><span class="inline-block align-text-bottom">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z"/></svg>
  </span>

</span></a
        >
      
    
      
        <a
          class="px-1 hover:text-primary-700 dark:hover:text-primary-400"
          href="https://github.com/lingyun67"
          target="_blank"
          aria-label="Github"
          rel="me noopener noreferrer"
          ><span class="inline-block align-text-bottom">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>

  </span>

</span></a
        >
      
    
  </div>

</div>
  </div>
</div>

      

      

      
      <div class="mb-5"></div>
      

    

  </header>
  
  <section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row">
    
    

      <div class="min-w-0 min-h-0 max-w-fit">
        
        


        <div class="article-content max-w-prose mb-20">
          

<h2 class="relative group">前言 
    <div id="%E5%89%8D%E8%A8%80" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%89%8D%E8%A8%80" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">.NET是什么 
    <div id="net%E6%98%AF%E4%BB%80%E4%B9%88" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#net%E6%98%AF%E4%BB%80%E4%B9%88" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>.NET是一个由微软公司研发的<strong>软件运行平台</strong>，现在基于Windows平台开发应用程序，大多采用.NET作为核心编程模型。</p>
<p>基于.NET平台开发软件，其中一个特点就是支持混合语言开发，微软官方维护的三种.NET编程语言为：C#、VB、F#。因为无论使用哪种语言开发，都要编译为同一种中间语言。</p>
<p>可以简单地把这些中间语言理解为.NET虚拟计算机所能直接执行的汇编语言。</p>
<p>只要编译器能把某种语言编译为此中间语言，那么他就能在.NET平台上运行。</p>
<p>新的.NET Core可以跑在各种平台上，不只局限于Windows。</p>


<h3 class="relative group">新一代的编程模型 
    <div id="%E6%96%B0%E4%B8%80%E4%BB%A3%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%96%B0%E4%B8%80%E4%BB%A3%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>Windows的.NET Framework平台构成为 CLR(Common Language Runtime) + 基类库(包容大量可重用软件组件)</p>


<h2 class="relative group">Visual Studio编写C#基础知识 
    <div id="visual-studio%E7%BC%96%E5%86%99c%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#visual-studio%E7%BC%96%E5%86%99c%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">计算机运行程序流程 
    <div id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">使用0和1表达信息 
    <div id="%E4%BD%BF%E7%94%A80%E5%92%8C1%E8%A1%A8%E8%BE%BE%E4%BF%A1%E6%81%AF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BD%BF%E7%94%A80%E5%92%8C1%E8%A1%A8%E8%BE%BE%E4%BF%A1%E6%81%AF" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>数值信息：直接使用二进制表达</p>
<p>非数值信息：采用&quot;编码&quot;。比如五笔输入法用一到四个字符对应一到多个汉字，而图像用数字表达每一个像素点和位置等信息，以特定格式写入到文件。</p>
<p>&ldquo;<strong>编码</strong>&ldquo;就是以若干位数码(或符号)的不同组合来表示非数值类型的信息，他人为地为数码(或符号)的每一种组合指定了一种特定的含义</p>


<h4 class="relative group">两种不同的内存类型 
    <div id="%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%86%85%E5%AD%98%E7%B1%BB%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%86%85%E5%AD%98%E7%B1%BB%E5%9E%8B" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>物理内存：单台计算机上安装的物理储存芯片所提供的内存</p>
<p>虚拟内存：由操作系统在硬盘上划出一块空间所提供的虚拟内存，可以比物理内存大很多。</p>
<p>使用C#所写的.NET程序，<strong>无法直接访问</strong>物理内存上的特定存储单元，它所访问的是由操作系统(如Windows)所提供的虚拟内存</p>


<h3 class="relative group">HelloWorld 
    <div id="helloworld" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#helloworld" aria-label="锚点">#</a>
    </span>        
    
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span> <span class="c1">//使用.NET基类库中的System命名空间</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">Program</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Press any key...&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>使用记事本时：保存文件为<code>.cs</code>文件，编码<code>ANSI</code>，然后对其进行编译：</p>
<p>搜索<code>command</code>，可以看到VS所提供的命令提示符 如<code>x64 Native Tools Command Prompt for VS 2019</code>，打开后转到<code>.cs</code>文件保存的目录</p>
<pre tabindex="0"><code>E:\&gt;cd /d C:\Users\LingYun67\source\repos\C_Sharp_HelloWorld\

C:\Users\LingYun67\source\repos\C_Sharp_HelloWorld&gt;csc.exe /target:exe Program.cs
Microsoft(R) Visual C# 编译器 版本 3.10.0-4.21269.26 (02984771)
版权所有(C) Microsoft Corporation。保留所有权利。


C:\Users\LingYun67\source\repos\C_Sharp_HelloWorld&gt;
csc.exe /target:exe Program.cs
调用编译器 将生成exe
</code></pre>

<h3 class="relative group">控制台程序输入输出 
    <div id="%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA" aria-label="锚点">#</a>
    </span>        
    
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">//输出一段提示</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&#34;请输入字符串&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//字符串变量userInput接收用户输入</span>
</span></span><span class="line"><span class="cl"><span class="kt">string</span> <span class="n">userInput</span> <span class="p">=</span> <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">//输出提示和变量</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;User input:&#34;</span> <span class="p">+</span> <span class="n">userInput</span><span class="p">);</span>
</span></span></code></pre></div><p>C#的输出也可以使用<strong>占位符</strong>的方式，感觉形式上类似于c语言的%s</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">//输出提示和变量</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;User input:&#34;</span> <span class="p">+</span> <span class="n">userInput</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//使用{0}占位符输出变量</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;User input:{0}&#34;</span><span class="p">,</span> <span class="n">userInput</span><span class="p">);</span>
</span></span></code></pre></div><p>占位符的好处在于方便的拼合多个字符串</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">//userInput.length是string的属性</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;User input:{0} length:{1}&#34;</span><span class="p">,</span> <span class="n">userInput</span><span class="p">,</span> <span class="n">userInput</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//转义字符也可以用</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;User input:{0} \nlength:{1}&#34;</span><span class="p">,</span> <span class="n">userInput</span><span class="p">,</span> <span class="n">userInput</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
</span></span></code></pre></div><p>例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nn">SayHello_</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">Program</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">TestInputAndOutput</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">static</span> <span class="k">void</span> <span class="n">TestInputAndOutput</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&#34;请输入一串字符:&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="kt">string</span> <span class="err">一串字符</span> <span class="p">=</span> <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;你输入的是{0},它的长度为{1}&#34;</span><span class="p">,</span> <span class="err">一串字符</span><span class="p">,</span> <span class="err">一串字符</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>才发现之前的两篇笔记没有记转义字符表</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th>ASCLL码值(十进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>'</td>
<td>代表一个单引号</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>\</td>
<td>代表一个反斜线字符&rsquo;''</td>
<td>092</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>空字符(NUL)</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>十六进制所代表的任意字符</td>
<td>十六进制</td>
</tr>
</tbody>
</table>


<h3 class="relative group">ReadKey和Beep 
    <div id="readkey%E5%92%8Cbeep" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#readkey%E5%92%8Cbeep" aria-label="锚点">#</a>
    </span>        
    
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">//等待用户输入一个字符，这个字符会显示在控制台里</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&#34;请输入字符：&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">//加入元素true则不会显示用户输入的字符</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&#34;\n请输入字符：&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</span></span></code></pre></div><p>比如两次readkey都输入一个A控制台内则会如下显示：</p>
<pre tabindex="0"><code>请输入字符：A
请输入字符：(此处输入A后程序自动关闭)
</code></pre><p>计算机beeeee一下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">Beep</span><span class="p">();</span>
</span></span></code></pre></div>

<h3 class="relative group">C#基本编程规则 
    <div id="c%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%A7%84%E5%88%99" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#c%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%A7%84%E5%88%99" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p><strong>标识符</strong>(identtifier),即程序中拥有特殊含义的单词,比如类或者方法)：区分大小写</p>
<p>每条语句以分号结尾，多条语句可以使用{}组合为一个语句块</p>
<p>编写的代码放在类(class)中，<strong>类是C#编程的基本单元</strong></p>
<p>存放C#类的源代码文件其扩展名为&rdquo;<strong>.cs</strong>&quot;，一个&rdquo;.cs&quot;文件中可以存放多个C#类</p>


<h3 class="relative group">Visual Studio中的文件组织方式 
    <div id="visual-studio%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#visual-studio%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>一个解决方案可以含有多个项目，项目(Project)是VS编译的最小单元</p>
<p>设置为启动项目的项目在启动的时候会启动</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/03/image-4.png" alt="img" />
    
  </figure>

</p>


<h2 class="relative group">面向对象程序设计概述 
    <div id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0" aria-label="锚点">#</a>
    </span>        
    
</h2>
<p>windows平台下，可以执行的文件通常是以.exe结尾的。另有一种扩展名为.dll的文件（称为“动态链接库”）它需要被.exe装入后才能执行</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-1.png" alt="img" />
    
  </figure>

</p>


<h3 class="relative group">.NET运行机理 
    <div id="net%E8%BF%90%E8%A1%8C%E6%9C%BA%E7%90%86" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#net%E8%BF%90%E8%A1%8C%E6%9C%BA%E7%90%86" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">编译是怎么回事 
    <div id="%E7%BC%96%E8%AF%91%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BC%96%E8%AF%91%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>纯文本形式的源代码—提交—C#编译器编译源代码—&gt;生成—&gt;二进制形式的可执行文件(HelloWorld.exe)</p>
<p>&ldquo;编译(compile)&ldquo;有点类似于&quot;翻译&rdquo;，粗略的说，它负责把人编写的源代码&quot;翻译&quot;为计算机可以识别并执行的二进制代码。</p>


<h4 class="relative group">而可执行程序也是<strong>分类</strong>的： 
    <div id="%E8%80%8C%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E4%B9%9F%E6%98%AF%E5%88%86%E7%B1%BB%E7%9A%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%80%8C%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E4%B9%9F%E6%98%AF%E5%88%86%E7%B1%BB%E7%9A%84" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>可执行程序文件也分多种类型，在Windows平台下可分为：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-2.png" alt="img" />
    
  </figure>

</p>
<p>本课程学习的基本上都是托管程序</p>


<h4 class="relative group">“托管的”应用程序是什么意思： 
    <div id="%E6%89%98%E7%AE%A1%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%89%98%E7%AE%A1%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>.NET应用程序是“托管(Managed)”的，意思是他必须在一个独立的运行环境(即CLR)中运行，并受到这个运行环境的管理与控制。没有环境程序无法运行</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-3.png" alt="img" />
    
  </figure>

</p>
<p><strong>CLR</strong>：Common Language Runtime，通用语言运行时。是.NET Framework应用程序的运行环境，可以看成是一台专用于运行.NET应用程序的虚拟机（Virtual Machine）。</p>
<p>到了.NET Core时代，.NET虚拟机名字前也加了一个Core，称为“CoreCLR”</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-4-1024x557.png" alt="img" />
    
  </figure>

</p>
<p>.exe和.dll在.NET中统称为 “程序集（Assembly）”，在程序集这种文件中保存的是二进制的指令，在.NET中被称为中间语言指令。</p>


<h3 class="relative group"><strong>怎样构造求解问题的算法</strong> 
    <div id="%E6%80%8E%E6%A0%B7%E6%9E%84%E9%80%A0%E6%B1%82%E8%A7%A3%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%97%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%80%8E%E6%A0%B7%E6%9E%84%E9%80%A0%E6%B1%82%E8%A7%A3%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%97%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>计算机中的<strong>算法</strong>，主要指为了解决某个问题而设计的一种解决方案，包容一系列计算机能够执行的有着特定顺序的命令，计算机执行完这些命令，将得到某种结果，意味着某个问题己经有了一个结论。</p>
<p>算法的针对性很强，专用于解决特定的问题。</p>
<p>算法的设计，通常与数学有着很密切的联系，并且是<strong>独立于</strong>特定的编程语言和软件平台的。这就是说：</p>
<p>可以使用多种编程语言，以多种方式，在不同的平台上实现同一个算法。</p>


<h3 class="relative group">从“结构化”到“面向对象” 
    <div id="%E4%BB%8E%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BB%8E%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>结构化方法是一种历史悠久的软件开发方法，是面向对象方法的前身。</p>


<h4 class="relative group">程序设计可以看成是一种&quot;抽象&quot;的艺术 
    <div id="%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E6%88%90%E6%98%AF%E4%B8%80%E7%A7%8D%E6%8A%BD%E8%B1%A1%E7%9A%84%E8%89%BA%E6%9C%AF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E6%88%90%E6%98%AF%E4%B8%80%E7%A7%8D%E6%8A%BD%E8%B1%A1%E7%9A%84%E8%89%BA%E6%9C%AF" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>使用“抽象”的思维方式，构造软件系统的顶层模型</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-5.png" alt="img" />
    
  </figure>

</p>


<h4 class="relative group">数据结构——对数据进行抽象 
    <div id="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%8A%BD%E8%B1%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%8A%BD%E8%B1%A1" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>先确定一种数据结构 ，然后基于此数据结构设计算法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">MyDate</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="n">Year</span><span class="p">;</span>    <span class="c1">//年</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="n">Month</span><span class="p">;</span>   <span class="c1">//月</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="n">Day</span><span class="p">;</span>     <span class="c1">//日</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>MyDate这个数据结构，封装了 “年”“月”“日”三个基本信息</p>
<p>在程序设计中，依据要解决的特定问题，分析它所涉及的相关数据和其中所蕴含的各种信息，按照特定编程语言所支持的语法特性，将它们转换为特定的数据结构，往往是整个开发中至关重要的一步。</p>


<h4 class="relative group">基于数据结构确定算法 
    <div id="%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A1%AE%E5%AE%9A%E7%AE%97%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A1%AE%E5%AE%9A%E7%AE%97%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>将人的计算方法转为计算机算法：</p>
<p>（1） 计算出两个日期之间的整年天数
（2） 计算出两个日期之间的整月天数（去掉中间的整年）</p>
<p>每个算法步骤用(定义)一个函数来实现：</p>
<p>CalculateDaysBetweenTwoYear()
CalculateDaysBetweenTwoMonth()</p>
<p>算法就是一系列的命令，计算机通过执行这些命令，完成特定的数据处理工作。</p>


<h4 class="relative group">进一步细化与调整设计方案 
    <div id="%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%BB%86%E5%8C%96%E4%B8%8E%E8%B0%83%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%BB%86%E5%8C%96%E4%B8%8E%E8%B0%83%E6%95%B4%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>需要判断是否是闰年，所以应该添加一个**IsLeapYear()**函数。</p>
<p>再添加一个顶层主控函数<strong>CalculateDaysBetweenTwoDate()</strong>，将前面设计得到的函数“装配”起来，从而实现整个算法。</p>


<h4 class="relative group">最终的技术设计方案 
    <div id="%E6%9C%80%E7%BB%88%E7%9A%84%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%9C%80%E7%BB%88%E7%9A%84%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-6-1024x490.png" alt="img" />
    
  </figure>

</p>
<p>如何确定开发顺序？</p>


<h4 class="relative group">确定开发顺序的基本方法 
    <div id="%E7%A1%AE%E5%AE%9A%E5%BC%80%E5%8F%91%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%A1%AE%E5%AE%9A%E5%BC%80%E5%8F%91%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>具体开发时，“从下层到上层”地逐层开发，就象盖楼一样&hellip;.</p>
<p>①先开发那些被别人调用，自己不调用别人的函数 <strong>IsLeapYear()</strong></p>
<p>②↓开发中间层函数，它需要调用底层已经实现好的函数</p>
<p><strong>CalculateDaysBetweenTwoYear()
CalculateDaysBetweenTwoMonth()</strong></p>
<p>③↓↓开发顶层函数，它需要调用中间层已经实现好的函数，通常情况下，避免跨层调用。</p>
<p><strong>CalculateDaysBetweenTwoDate()</strong></p>
<p>在结构化的编程中，有一个基本的编程原则就是尽量的<strong>避免出现跨层调用</strong>的情况，比如主控函数不要调用判断闰年的函数，而反过来则更不允许，底层的函数绝对不能调用高层的函数。</p>


<h4 class="relative group">转为面向对象实现 
    <div id="%E8%BD%AC%E4%B8%BA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%BD%AC%E4%B8%BA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>将函数们移动到一个新的类里——</p>
<p>重大变化：</p>
<ol>
<li>新的类DateCalculator的<strong>指责很明确</strong>，它负责“计算日期”，除此之外，它什么也不干。</li>
<li>外界只能“看到”并调用它所定义的唯一一个“<strong>公有（public）</strong>”方法CalculateDaysOfTwoDate()，根本就不知道它内部到底是怎么计算出来的。</li>
</ol>
<p>也就是将除了主函数之外的函数设为私有，仅公开主函数。</p>
<p>面向对象带来的好处：</p>
<ol>
<li>从使用者角度，DateCalculator类因为 “<strong>简单</strong>”，所以“<strong>易用</strong>”。</li>
<li>具体计算日期的算法被封装到了DateCalculator类的内部，<strong>在必要时可以修改算法</strong>，外部调用者<strong>不会受到影响</strong>，其调用代码不需要改变。</li>
</ol>
<p>一个&quot;偷懒&quot;的方法：</p>
<p>.NET基类库中内置了日期处理的相关功能，可以直接使用它来完成计算两个日期之间相隔天数的问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">DateTime</span> <span class="n">d1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">DateTime</span><span class="p">(</span><span class="m">1999</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">DateTime</span> <span class="n">d2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">DateTime</span><span class="p">(</span><span class="m">2006</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//计算结果</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">days</span> <span class="p">=</span> <span class="p">(</span><span class="n">d2</span> <span class="p">-</span> <span class="n">d1</span><span class="p">).</span><span class="n">TotalDays</span><span class="p">;</span> 
</span></span></code></pre></div><p>从这个示例中，我们可以看到，如果有一个功能强大的组件库，基于这些组件开发应用程序，可以大大地提升软件开发效率，因为我们可以重用别人的工作，不再需要一切从头开始。</p>


<h2 class="relative group">C#结构化编程基础 
    <div id="c%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#c%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">理解变量 
    <div id="%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>程序运行所需要处理的数据，通常都需要放到“<strong>变量（variable）</strong>”中。</p>
<p>变量可以看作是一种数据容器。</p>
<p>不同类型的“容器”，适合放置不同类型的数据，这种“类型”，我们称它为“<strong>变量的数据类型</strong>”。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="err">数据类型名称</span> <span class="err">变量名</span> <span class="p">=</span> <span class="err">变量初始值</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="k">value</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
</span></span></code></pre></div><p>上述语句定义了一变量，它的类型是“<strong>int（整型）</strong>”，可以放置一个<strong>整数</strong>，它最初“装入”的数是“<strong>100</strong>”。</p>
<p><em>C#语句以“分号”结束，因此分号不能省，省略了之后，代码将无法编译。</em></p>
<p><strong>变量“生活”在“内存（memory ）”中</strong></p>
<p>应用程序中能使用的内存，是由操作系统提供的“<strong>虚拟内存</strong>”，其物理载体通常是我们在前一单元视频中介绍过的内存条和硬盘。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-7.png" alt="img" />
    
  </figure>

</p>
<p>内存由多个内存单元构成，每个内存单元都有一个编号，称为“内存地址”。</p>
<p>给定一个“内存地址”，就能找到特定的内存单元。</p>
<p>计算机可以从内存单元中写入或读出数据。</p>
<p>使用比较底层的编程语言，比如“<strong>汇编语言（Assembly Language）</strong>”，我们可以直接指定地址去存取特定的内存单元，但这么干“太低效了”，为什么？</p>
<ol>
<li>不同的计算机硬件，可以访问的物理内存数量是变化的 比如搭载的内存条不同</li>
<li>不同的操作系统，甚至是同一操作系统的不同版本，对内存单元的存取可能都有着不同的要求
例如32位的Windows能够访问的最大内存是4G.</li>
</ol>
<p>你必须针对特定的计算机去写“特定”的程序，硬件略有变化，如果不作修改，你的程序可能就崩溃了……</p>
<p>因此这种编程方法是行不通而且十分低效的。</p>
<p><strong>计算机科学家给出的解决方案是……</strong></p>
<ol>
<li>应用程序需要存取数据时，不指定具体的内存地址值，而只是给出一个“名字”，这个“名字”引用某块内存区域。</li>
<li>这个“名字”具体到底引用的是哪块内存区域，由操作系统（Windows）负责安排，应用程序就不要费这个心了！</li>
<li>应用程序根本就不管它要用的数据具体保存在哪个地方，它只知道，我可以“按名”存取数据就够了！</li>
</ol>
<p>这个内存区域的“名字”，就是我们所讲的“<strong>变量</strong>”！</p>
<p><strong>通过变量名“间接”地存取内存</strong></p>
<p><strong>int i = 0;</strong></p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-8.png" alt="img" />
    
  </figure>

</p>
<p>变量名—对应于—某块内存区域的“别名”</p>
<ul>
<li>变量的名字（上面代码中的“i ”)，可以看成是特定内存区域的 “别名”，通过它计算机就能找到特定的内存单元存取数据。</li>
<li>有了变量名，就不再需要显式指定一长串的地址数值来访问内存单元了。</li>
</ul>
<p><strong>“给变量赋值”是什么意思？</strong></p>
<p>变量定义好之后，可以随时地通过<strong>赋值语句</strong>传给它不同的值……</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="err">变量名</span> <span class="p">=</span> <span class="err">变量新值</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">i</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
</span></span></code></pre></div><p>C#代码中的单个等号，称为“<strong>赋值符</strong>”，与数学中的等号是两回事，它表示要把等号右边的值，传给左边的变量。</p>
<p>给变量<strong>赋值</strong>，其实就是找到变量所代表的内存区域，把指定的数值写入其中。</p>
<p>注意：写入到内存单元中的数据，都被转换为<strong>二进制</strong>数值，计算机并不能直接处理我们常用的十进制数。</p>
<p>变量间的相互赋值，本质上是内存单元间的<strong>值复制</strong>。
在上述代码中，j = i，其实就是把“i”中所保存的数值复制一份，然后保存到“j”所代表的内存单元中。
注意：变量“i ”和“ j”之间是<strong>完全独立的</strong>，修改“i”的值，不会导致“j”的值同步变化。</p>


<h3 class="relative group">数据类型 
    <div id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">四种最常用的数据类型 
    <div id="%E5%9B%9B%E7%A7%8D%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9B%9B%E7%A7%8D%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" aria-label="锚点">#</a>
    </span>        
    
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">intValue</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">long</span> <span class="n">longValue</span> <span class="p">=</span> <span class="m">100l</span><span class="p">;</span> <span class="c1">//这里是100L</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">doubleValue</span> <span class="p">=</span> <span class="m">100.5d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">floatValue</span> <span class="p">=</span> <span class="m">100.5f</span><span class="p">;</span>
</span></span></code></pre></div><p>如果希望知道一个变量的数据类型：</p>
<p>调用**GetType()**方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">intValue</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">longValue</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">doubleValue</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">floatValue</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>
</span></span></code></pre></div><p>输出如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">System</span><span class="p">.</span><span class="n">Int32</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="p">.</span><span class="n">Int64</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="p">.</span><span class="n">Double</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="p">.</span><span class="n">Single</span>
</span></span></code></pre></div><p>另外，也可以使用另一种方法**tyoepf();**用来验证某一个变量是否是特定的类型</p>
<pre tabindex="0"><code>Console.WriteLine(intValue.GetType()typeof(int));
</code></pre><p>我们因此得知，我们可以用<strong>GetType</strong>获取变量的类型，用<strong>typeof</strong>验证变量的类型。</p>
<p>因为intValue是int类型，所以上述WriteLine会输出一个bool:true</p>
<p>由上可以看出C#内置的数据类型是<strong>对应着</strong>CLR支持的基础数据模型的</p>
<table>
<thead>
<tr>
<th>int</th>
<th>System.Int32</th>
</tr>
</thead>
<tbody>
<tr>
<td>long</td>
<td>System.Int64</td>
</tr>
<tr>
<td>float</td>
<td>System.Double</td>
</tr>
<tr>
<td>double</td>
<td>System.Single</td>
</tr>
</tbody>
</table>
<p>我们使用的这些C#的内置数据类型在编译的时候会<strong>被转变</strong>为CLR支持的基础的数据类型</p>


<h4 class="relative group">C# 7中对整数的改进 
    <div id="c-7%E4%B8%AD%E5%AF%B9%E6%95%B4%E6%95%B0%E7%9A%84%E6%94%B9%E8%BF%9B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#c-7%E4%B8%AD%E5%AF%B9%E6%95%B4%E6%95%B0%E7%9A%84%E6%94%B9%E8%BF%9B" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>C# 7之后的版本，对于比较大的整数，可以使用下划线对其进行分割，以方便人阅读：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">long</span> <span class="n">distanceToSunFromEarth</span> <span class="p">=</span> <span class="m">149_600_000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//输出：149600000</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">distanceToSunFromEarth</span><span class="p">);</span>
</span></span></code></pre></div><p>对于二进制数值（以“0b”打头），也可以直接地添加下划线进行分割：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">//定义一个二进制的数值</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">b</span> <span class="p">=</span> <span class="m">0</span><span class="n">b1010_1011_1100_1101_1110_1111</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//输出（十进制）：11259375</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span></code></pre></div>

<h4 class="relative group">String和var 
    <div id="string%E5%92%8Cvar" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#string%E5%92%8Cvar" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>在定义字符串的时候，首字母大写与小写都可以成功定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">str1</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>
</span></span><span class="line"><span class="cl"><span class="kt">string</span> <span class="n">str2</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>
</span></span></code></pre></div><p>如果对他们进行判断 会发现他们是<strong>完全相同</strong>的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">str1</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">str2</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">String</span><span class="p">)</span><span class="k">typeof</span><span class="p">(</span><span class="kt">string</span><span class="p">));</span><span class="c1">//true</span>
</span></span></code></pre></div><p>这是因为在编译的时候，编译器会将它们两者都编译为System.String，两者都对应着System.String</p>
<p>所以在定义字符串的时候完全可以混用两种写法。</p>
<p>但还是建议使用小写写法，<strong>小写是C#基本数据类型的书写习惯</strong>。</p>
<p>隐式类型变量——var</p>
<p>var关键字定义的变量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">value1</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">value1</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">//System.Int32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">value2</span> <span class="p">=</span> <span class="s">&#34;Hello&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">value2</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">//System.String</span>
</span></span></code></pre></div><p>C#编译器在编译的时候会依据右值来推断左值的类型</p>
<p>我们把这种方式定义的变量称为隐式类型变量</p>
<p>主要目的是精简代码</p>
<p>比如定义下面的变量的简化</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">Dicrionary</span><span class="p">&gt;</span> <span class="n">dic</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dicrionary</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">dic</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dicrionary</span><span class="p">&gt;;</span>
</span></span></code></pre></div>

<h4 class="relative group">dynamic——变色龙 
    <div id="dynamic%E5%8F%98%E8%89%B2%E9%BE%99" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#dynamic%E5%8F%98%E8%89%B2%E9%BE%99" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>C# 4.0引入了一个dynamic类型，它是一条变色龙，可以动态地给它添加数据成员，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="cs">///</span>
</span></span><span class="line"><span class="cl"><span class="cs">///可以动态添加成员的数据类型</span>
</span></span><span class="line"><span class="cl"><span class="cs">///</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">static</span> <span class="k">void</span> <span class="n">DynamicTypeDemo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//dynamic是一种“神奇”的数据类型，它所定义的变量，可以动态的添加成员</span>
</span></span><span class="line"><span class="cl">    <span class="kt">dynamic</span> <span class="n">obj</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Expandobject</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//给它添加一个int类型的属性</span>
</span></span><span class="line"><span class="cl">    <span class="n">obj</span><span class="p">.</span><span class="n">intValue</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//给它添加一个方法</span>
</span></span><span class="line"><span class="cl">    <span class="n">Action</span> <span class="n">act</span> <span class="p">=</span> <span class="p">(</span><span class="n">Value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">Value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">obj</span><span class="p">.</span><span class="n">printValue</span> <span class="p">=</span> <span class="n">act</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//调用新添加的方法输出新添加的属性值</span>
</span></span><span class="line"><span class="cl">    <span class="n">obj</span><span class="p">.</span><span class="n">printValue</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">intValue</span><span class="p">);</span><span class="c1">//100</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>dynamic实际上定义了一种“动态”对象，它支持在运行过程中动态地添加新成员，一切是在“运行”时发生的。</p>
<p>而var只是你<strong>写</strong>代码时可以不指定类型，其实它的类型是明确的，这个类型的成员也是固定的，由它所接收的值所决定。这一切，都是在“编译”时确定。</p>
<p>当前可以对dynamic类型“不求甚解”，知道有它就好。</p>


<h4 class="relative group">变量与内存 
    <div id="%E5%8F%98%E9%87%8F%E4%B8%8E%E5%86%85%E5%AD%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%86%85%E5%AD%98" aria-label="锚点">#</a>
    </span>        
    
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span>
</span></span></code></pre></div><p>返回的是（单位：字节）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="m">4</span>
</span></span><span class="line"><span class="cl"><span class="m">8</span>
</span></span><span class="line"><span class="cl"><span class="m">4</span>
</span></span><span class="line"><span class="cl"><span class="m">8</span>
</span></span></code></pre></div><p>在C#中较低精度/较小范围类型到较高精度/较大范围类型的转换赋值是可以的,比如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">longVaule</span> <span class="p">=</span> <span class="n">intVaule</span>
</span></span><span class="line"><span class="cl"><span class="n">doubleVaule</span> <span class="p">=</span> <span class="n">intVaule</span>
</span></span><span class="line"><span class="cl"><span class="n">doubleVaule</span> <span class="p">=</span> <span class="n">floatVaule</span>
</span></span></code></pre></div><p>但是反过来从较高精度/较大范围类型到较低精度/较小范围类型的转换时会报错提示无法隐式转换</p>
<p>所以如果需要强制类型转换</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">intVaule</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">longVaule</span>
</span></span><span class="line"><span class="cl"><span class="n">intVaule</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">doubleVaule</span>
</span></span><span class="line"><span class="cl"><span class="n">floatVaule</span> <span class="p">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">doubleVaule</span>
</span></span></code></pre></div><p>一个特殊的点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">floatVaule</span> <span class="p">=</span> <span class="n">intVaule</span> <span class="c1">//事实上float比int表达的范围要大</span>
</span></span><span class="line"><span class="cl"><span class="n">intVaule</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">floatVaule</span> <span class="c1">//不加强制类型转换会报错</span>
</span></span></code></pre></div>

<h4 class="relative group">数据类型转换 
    <div id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>字符串&quot;100&quot;向数值转换：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">string</span> <span class="p">=</span> <span class="n">strValue</span> <span class="p">=</span> <span class="s">&#34;100&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">intValue</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">strValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">doubleValue</span> <span class="p">=</span> <span class="kt">double</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">strValue</span><span class="p">);</span>
</span></span></code></pre></div><p>C#基类库中的一个类也可以实现这个功能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">intValue</span> <span class="p">=</span> <span class="n">Convert</span><span class="p">.</span><span class="n">ToInt32</span><span class="p">(</span><span class="n">strValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">doubleValue</span> <span class="p">=</span> <span class="n">Convert</span><span class="p">.</span><span class="n">ToDouble</span><span class="p">(</span><span class="n">strValue</span><span class="p">);</span>
</span></span></code></pre></div><p>反过来希望一个数据转换为字符串</p>
<p>ToString方法很通用、几乎所有的原始数据类型都有这个方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">strValue</span> <span class="p">=</span> <span class="n">intValue</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">strValue</span> <span class="p">=</span> <span class="n">doubleValue</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">strValue</span> <span class="p">=</span> <span class="m">200.</span><span class="n">ToString</span><span class="p">();</span> <span class="c1">//因为200是int32所以完全没问题</span>
</span></span></code></pre></div><p>另外一种转字符串的方法是</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">strValue</span> <span class="p">=</span> <span class="n">intValue</span> <span class="p">+</span> <span class="s">&#34;&#34;</span><span class="p">;</span><span class="c1">//加上一个空字符</span>
</span></span></code></pre></div><p>虽然后者是完全可用的但是还是建议使用ToString</p>


<h4 class="relative group">C#变量两种类型 
    <div id="c%E5%8F%98%E9%87%8F%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#c%E5%8F%98%E9%87%8F%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>从内存模型角度，C#变量可分为以下这两种类型</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-10.png" alt="img" />
    
  </figure>

</p>
<p>线程堆栈/堆（一种特殊的内存区域）</p>
<p>这两种都是特定的内存区域，有不同的特点。目前只需要知道大致分为两种类型</p>


<h3 class="relative group">运算符与表达式 
    <div id="%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>与c一样，除号两边都是整数的时候是按照整除的方式来处理的，是商。</p>
<p>如果给其中一个加上后缀d或者.0都是可以的</p>
<p>加减乘除都一样 递增递减一样</p>


<h3 class="relative group">选择结构与逻辑表达式 
    <div id="%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E4%B8%8E%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E4%B8%8E%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">三种典型的程序代码执行流程 
    <div id="%E4%B8%89%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%89%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-11.png" alt="img" />
    
  </figure>

</p>
<p>在结构化程序设计中，经常使用一种称为“ 程序流程图 ”的示意图 来表示程序的执行流程 。</p>
<p>虽然在面向对象时代，流程图用得没有以前多了，但由于其拥有直观性强的优点，仍然被广泛使用 ，比如在行业应用软件系统开发时 ，使用流程图表达业务流程的处理步骤，几乎所有人都能看得懂。</p>


<h4 class="relative group">if/else选择结构 
    <div id="ifelse%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#ifelse%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84" aria-label="锚点">#</a>
    </span>        
    
</h4>
<ul>
<li>逻辑表达式通常用于表示某种条件是否得到满足。</li>
<li>当程序运行时，计算机解析逻辑表达式，会得到一个值，在C#中，这个值只有“true（真）”或“false（假）”两种情况。表达式值为 “true”，表示条件满足，为“false”，表示条件不满足。</li>
<li>在 if 语句中，基于逻辑表达式执行的结果执行特定的分支。</li>
<li>嵌套在条件语句内部的条件语句，整个语句被当作一个语句块处理，可以看成是一个整体</li>
<li>除非使用“{”和“}”为语句划分了块，否则，else总是与它最近的if配套。</li>
<li>弄错“if”和“else”的配套关系，有可能会带来严重的问题，推荐加上足够的“{”和“}”给与明确区分。</li>
</ul>


<h4 class="relative group">区分关键字与标识符 
    <div id="%E5%8C%BA%E5%88%86%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%A0%87%E8%AF%86%E7%AC%A6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8C%BA%E5%88%86%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%A0%87%E8%AF%86%E7%AC%A6" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-12.png" alt="img" />
    
  </figure>

</p>


<h4 class="relative group">用于构建逻辑表达式的运算符 
    <div id="%E7%94%A8%E4%BA%8E%E6%9E%84%E5%BB%BA%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%94%A8%E4%BA%8E%E6%9E%84%E5%BB%BA%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6" aria-label="锚点">#</a>
    </span>        
    
</h4>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>大于，实例：“5&gt;10”，值为“false”</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td></td>
<td>等于，实例：“ 9 100”，值为“false”</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于，实例：“100 != 101”，值为“true”</td>
</tr>
</tbody>
</table>
<p>“=&gt;”不是“等于大于”，它在C#程序中有特定的含义，它表示一个Lambda表达式，也可以用于标识“表达式成员”，我们将在后面的课程中对这两种情形进行介绍。</p>


<h4 class="relative group">逻辑表达式的组合 
    <div id="%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BB%84%E5%90%88" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BB%84%E5%90%88" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>使用“&amp;&amp;”组合两个表达式，只有两个条件都满足（都为“true”）时，整个条件才算满足，可以将“&amp;&amp;”与汉语中的“并且”对应上。</p>
<p>&amp;&amp;（And /与）、||（Or/或）、!（Not/非）</p>
<p>与或非</p>
<p>假设Ａ和Ｂ都是一个逻辑表达式，对其使用与、或、非组合运算的规律如下：</p>
<ol>
<li>A &amp;&amp; B：只有Ａ和Ｂ都为true，结果才为true</li>
<li>A || B：只要A和B中有一个为true，结果就为true</li>
<li>!A：结果总是与A“相反”，比如A为true，则!A为false</li>
</ol>


<h4 class="relative group">多值选择结构 switch_case 
    <div id="%E5%A4%9A%E5%80%BC%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84-switch_case" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%A4%9A%E5%80%BC%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84-switch_case" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>为了保证一个值执行一个分支，每个分支后都应该加一个break;语句（最后一个分支可略）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">static</span> <span class="k">void</span> <span class="n">DoYouPass</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&#34;请输入你的考试成绩：&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">string</span> <span class="n">UserInput</span> <span class="p">=</span> <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">score</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">UserInput</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">score</span><span class="p">/</span><span class="m">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="m">10</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="m">9</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;学霸&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="m">8</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;好&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="m">7</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;还行&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="m">6</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;小心了&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;没及格&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h3 class="relative group">循环 
    <div id="%E5%BE%AA%E7%8E%AF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%BE%AA%E7%8E%AF" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>do/while循环的特点：
先做事，再判断循环条件是否满足，满足就继续执行循环体。</p>
<p>所谓“循环结构”，其实就是在特定的场景下，某些语句将被反复地执行多次。</p>
<p>while/do循环的特点：
先判断循环条件，满足了再做事。</p>
<p>当需要执行次数不定的循环时，使用do/while或while/do循环是最自然的选择。</p>
<p>当需要执行次数固定的循环时，使用for循环就变成了最自然的选择。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;=</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Hey! I am Trapped&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>执行顺序为 ①[int i = 0] ②[i&lt;= 100] ③[{}内代码] ④[i++]</p>
<p>break：提前结束循环，后面还没有执行的循环也不再执行。</p>
<p>continue：提前结束当前循环（本轮循环中还没有执行的代码不再执行），后面的循环继续执行。</p>
<p>“永远不结束”的“死循环”
在某些场景，无法预知到底要执行多少轮循环，也不知道要运行多长时间</p>
<ul>
<li>Windows需要时刻监控鼠标与键盘，以便及时地响应用户操作。</li>
<li>某股票软件需要及时地提取股票信息，将涨跌信息及时地通知用户</li>
<li>防病毒软件需要在后台监控各种活动，发现危险时向用户报警</li>
</ul>
<p>在这些场景中，使用“死循环” 是合理的</p>


<h4 class="relative group">使用循环结构访问数据集合 
    <div id="%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E9%9B%86%E5%90%88" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E9%9B%86%E5%90%88" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>在面向对象的软件中，我们会经常遇到“数据集合”这一概念。 “数据集合”，顾名思义，就是“数据的集合”，在实际开发中，有两种类型的数据集合我们经常会遇到……</p>
<ol>
<li>保存int、float等值类型数据的集合，如“List”</li>
<li>保存string和自定义类等引用类型数据的集合，如List，又称为“对象集合”</li>
</ol>
<p>要遍历这两种类型的数据集合，我们可以使用foreach循环……</p>


<h4 class="relative group">数据集合的“遍历” 
    <div id="%E6%95%B0%E6%8D%AE%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>所谓“遍历”，换一个说法，就是“逐个地访问”。</p>
<p>遍历数据集合最自然的方式，就是使用<strong>foreach</strong>循环。</p>
<p>使用foreach 遍历数据集合时，不要向集合中增删数据。</p>
<p>各种类型的循环语句都是等价的，可以把一种类型的循环语句用另一种类型的循环语句替换而不会影响到程序的功能。</p>
<p>从表面上看，foreach与前面介绍过的for, do/while等循环并没有什么区别，但实际上，两者是有很大区别的。</p>
<p>C#编译器在编译foreach语句时，会将其转换为使用IEnumerable与IEnumerator的相应代码，并且C# 8还引入了序列和异步循环迭代等新特性，这些内容，当前暂不介绍，而安排在后继的其他课程中，等你掌握了相应的知识之后再学习。</p>


<h3 class="relative group">控制台应用程序编程小技巧 
    <div id="%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E5%B0%8F%E6%8A%80%E5%B7%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E5%B0%8F%E6%8A%80%E5%B7%A7" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>当我们编写控制台应用程序时，经常需要知道用户是否按了某些特殊的键（比如F1键），于是问题出来了……</p>
<p>（1）我怎么知道用户按的是哪个键？
（2）怎样编程来检测用户的按键？</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-14.png" alt="img" />
    
  </figure>

</p>
<p>当一个控制台程序正在运行时，默认情况下，用户可以使用“Ctrl+C”或“Ctrl+Break”强制中止它的运行。</p>
<p>要禁用“Ctrl+C”的功能，可以设置以下属性</p>
<p>Console.TreatControlCAsInput = true;</p>


<h3 class="relative group">从语句到方法 
    <div id="%E4%BB%8E%E8%AF%AD%E5%8F%A5%E5%88%B0%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BB%8E%E8%AF%AD%E5%8F%A5%E5%88%B0%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>在实际开发中，我们经常会发现某些功能在很多程序中都需要。当然，你可以直接地在不同程序中“Copy &amp; Paste”代码，但这么干，麻烦很多：</p>
<p>当你发现了这些代码中有错误时，你必须找出它们被复制过的所有地方，一一更改，这实在太烦人了……</p>
<p>能不能把这些需要重复使用的代码“归作一堆”，给它起个名字，然后在需要调用它们时，只需指定一个名字即可？</p>
<p>把多个语句组合在一起，共同完成一个功能，向外界返回一个结果，再给它起个名字，这样的一个“代码集合”，在面向对象编程领域，称之为“<strong>方法（method）</strong>”。</p>
<p>在结构化编程领域，面向对象中的“方法（mothod）”被称为“<strong>函数（function）</strong>”，这两个术语经常混用，可以看成是一回事（虽然有细微的差别）。</p>
<p>在C# 9.0之前，所有方法都必须放到一个“<strong>类（class）</strong>”中，不存在完全独立的方法，9.0之后，允许你定义一个不放在类中的方法并立即调用它（还包括变量声明、类的定义、普通语句等），这个特性，称为“<strong>Top level Statements（顶级语句）</strong>”。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-15.png" alt="img" />
    
  </figure>

</p>
<p>调用Add()方法时传入的“100”和“200”，称为方法的“<strong>实参（实际参数）</strong>”。</p>
<p>注意：C#编程语言所定义的方法名字，首字母大写，其它许多编程语言，比如Java，习惯是小写字母开头，使用不同的编程语言，需要遵循相应的“惯例”。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kt">int</span> <span class="n">Add</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意上面代码的static关键字，它表明这个方法是一个“静态方法（static method）”。</p>
<p>C#中，位于同一个类的静态方法可以通过方法名直接调用，其它类要调用时，需要加上此方法所在的类名，比如：Program.Add（100,200）;</p>
<p>如果定义方法时没有加上static关键字，它表明这个方法是一个“实例方法（instance method）”，这种方法依附于特定的对象，外界需要通过对象变量来调用。这部分内容，留待后面课程介绍。</p>


<h4 class="relative group">方法的重载 
    <div id="%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD" aria-label="锚点">#</a>
    </span>        
    
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kt">int</span> <span class="n">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">static</span> <span class="kt">double</span> <span class="n">Add</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">static</span> <span class="kt">double</span> <span class="n">Add</span><span class="p">(</span><span class="kt">string</span> <span class="n">x</span><span class="p">,</span> <span class="kt">string</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">dx</span> <span class="p">=</span> <span class="kt">double</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">dy</span> <span class="p">=</span> <span class="kt">double</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">dx</span> <span class="p">+</span> <span class="n">dy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在同一个类中，我们可以定义名字一样的方法，只要它们的参数列表不一样就行了，这种语法特性，叫作“<strong>方法的重载（method overload）</strong>”</p>
<p>只需要达成以下条件之一，就可以构成方法重载的关系</p>
<ol>
<li>参数个数不一样</li>
<li>参数个数相同，但相同位置的参数，其类型不一样</li>
</ol>
<p>返回值类型不作为方法重载判断的依据。</p>
<p>对于重载方法，到底调用的是哪个，是由其<strong>参数</strong>决定的。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-17.png" alt="img" />
    
  </figure>

</p>


<h3 class="relative group">一个实例：图片浏览器 
    <div id="%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E5%99%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E5%99%A8" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>窗体内有如下元素：</p>
<ul>
<li>按钮button：btnchoosepicture</li>
<li>图片pictureBox：pictureBox1</li>
<li>文件选择openFileDialog：openFileDialog1</li>
</ul>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-18.png" alt="img" />
    
  </figure>

</p>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">private</span> <span class="k">void</span> <span class="n">button1_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">//关于这个button1按钮的代码</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">openFileDialog1</span><span class="p">.</span><span class="n">ShowDialog</span><span class="p">()</span>  <span class="n">DialogResult</span><span class="p">.</span><span class="n">OK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//openFileDialog1元素的打开情况有ok,canceled等</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pictureBox1</span><span class="p">.</span><span class="n">ImageLocation</span> <span class="p">=</span> <span class="n">openFileDialog1</span><span class="p">.</span><span class="n">FileName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//图片盒子的 图片地址 是 openFileDialog1 的 选择文件</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;User canceled.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//否则在消息输出一个字符串</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对openFileDialog1按下&quot;转到定义&rdquo; 可以看到</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">DialogResult</span> <span class="n">ShowDialog</span><span class="p">();</span>
</span></span></code></pre></div><p>而DialogResult是一个枚举</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl">    <span class="c1">//</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 摘要:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//     指定标识符来指示对话框中的返回值。</span>
</span></span><span class="line"><span class="cl"><span class="na">    [ComVisible(true)]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">enum</span> <span class="n">DialogResult</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 摘要:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//     Nothing 从对话框中返回。 这意味着模式对话框仍继续运行。</span>
</span></span><span class="line"><span class="cl">        <span class="n">None</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 摘要:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//     对话框中的返回值是 OK （通常从一个标有确定按钮发送）。</span>
</span></span><span class="line"><span class="cl">        <span class="n">OK</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 摘要:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//     对话框中的返回值是 Cancel （通常从一个标记为取消按钮发送）。</span>
</span></span><span class="line"><span class="cl">        <span class="n">Cancel</span> <span class="p">=</span> <span class="m">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 摘要:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//     对话框中的返回值是 Abort （通常从标记为中止的按钮发送）。</span>
</span></span><span class="line"><span class="cl">        <span class="n">Abort</span> <span class="p">=</span> <span class="m">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 摘要:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//     对话框中的返回值是 Retry （通常从标记为重试的按钮发送）。</span>
</span></span><span class="line"><span class="cl">        <span class="n">Retry</span> <span class="p">=</span> <span class="m">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 摘要:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//     对话框中的返回值是 Ignore （通常从标记为 Ignore 的按钮发送）。</span>
</span></span><span class="line"><span class="cl">        <span class="n">Ignore</span> <span class="p">=</span> <span class="m">5</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 摘要:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//     对话框中的返回值是 Yes （通常从一个标记为是按钮发送）。</span>
</span></span><span class="line"><span class="cl">        <span class="n">Yes</span> <span class="p">=</span> <span class="m">6</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 摘要:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//     对话框中的返回值是 No （通常从一个标记为无按钮发送）。</span>
</span></span><span class="line"><span class="cl">        <span class="n">No</span> <span class="p">=</span> <span class="m">7</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>将这个方法整理成函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">private</span> <span class="k">void</span> <span class="n">button1_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">openPicture</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="k">void</span> <span class="n">openPicture</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">openFileDialog1</span><span class="p">.</span><span class="n">ShowDialog</span><span class="p">()</span>  <span class="n">DialogResult</span><span class="p">.</span><span class="n">OK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pictureBox1</span><span class="p">.</span><span class="n">ImageLocation</span> <span class="p">=</span> <span class="n">openFileDialog1</span><span class="p">.</span><span class="n">FileName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;User canceled.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h3 class="relative group">递归 
    <div id="%E9%80%92%E5%BD%92" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%80%92%E5%BD%92" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p><strong>递归概述</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">static</span> <span class="k">void</span> <span class="n">DonotRunMe</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">DonotRunMe</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>递归就是“自己调用自己”</p>
<p>但是上述代码执行后会导致报错</p>
<p>小知识：堆栈溢出（Stack Overflow）</p>
<p>程序代码其实是由“<strong>线程（thread）</strong>”负责执行的。</p>
<p>操作系统在创建线程（thread）时，会给每个线程配套一块内存区域，线程可以用这块区域存储一些数据。</p>
<p>这块内存区域被称为“<strong>线程堆栈（thread stack）</strong>”</p>
<p>线程堆栈有容量限制，当一个线程要保存的数据超过了这个容量时，就发生了“<strong>堆栈溢出</strong>”</p>
<p>“递归（recursive）”的算法、</p>
<p>An algorithm is called recursive if it solves a problem by reducing it to an instance of the same problem with smaller input.</p>
<p>一个递归的算法，会将一个难以处理的“大”问题的 “规模”分多次地持续压缩，一直持续到压缩后的问题规模小到可以处理为止。其过程往往体现为代码要处理的数据量或计算量在递归前后不断“递减”。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-19.png" alt="img" />
    
  </figure>

</p>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;!{0}={1}&#34;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">digui</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">static</span> <span class="kt">int</span> <span class="n">digui</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">==</span><span class="m">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span> <span class="p">=</span> <span class="n">digui</span><span class="p">(</span><span class="n">x</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">*</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>小结：递归编程的“套路”</strong></p>
<ol>
<li>每个递归函数的开头一定是判断递归结束条件是否满足的语句（一般是if语句）</li>
<li>函数体一定至少有一句是“自己调用自己”的。</li>
<li>每个递归函数一定有一个控制递归可以终结的变量（通常是作为函数的参数而存在）。每次自己调用自己时，此变量会变化（通常是变小），并传送给被调用的函数。</li>
</ol>
<p><strong>小结：递归的特点</strong></p>
<ol>
<li>先从大到小，再从小到大。</li>
<li>每个步骤要干的事情都是类似的，只不过其规模 “小一号”。</li>
<li>必须要注意保证递归调用的过程可以终结，否则，将导致“<strong>堆栈溢出（stack overflow）</strong>”。</li>
</ol>
<p>下面我们再来看看另一种编程技巧——递推。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kt">long</span> <span class="n">Factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">==</span><span class="m">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="p">=</span> <span class="n">Factorial</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">*</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kt">long</span> <span class="n">Factorial2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">result</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="p">*=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>“递归”是“<strong>由后至前再回来</strong>”，要求第n项，先求第n-1项，……，倒推到前面的可计算出的某项，然后再返回。</p>
<p>“递推”是“<strong>从前到后</strong>”，先求第1项，然后，在此基础上求第2项，第3项，直至第n项。</p>
<p><strong>结论：递归与递推（iterative ）是等价的。</strong></p>
<p><strong>关于递归，再多说几句……</strong></p>
<p>• 在软件科学中，递归这种思想有着重要的应用，比如，许多计算机算法都是用递归实现的。
• 在具体的软件开发实践中，递归也用得非常多。
• 对于初学者而言，要一下子理解递归比较困难，只能在开发实践中慢慢体会，最终方能灵活地应用递归解决实际问题。</p>
<p>除了递归之外，还有一个非常重要的编程技巧是需要掌握的，那就是“回调”。回调在“多线程编程”场景中，还有在诸如JavaScript这样的编程语言写的程序中，被大量地使用。</p>


<h3 class="relative group">大数与浮点数的编程技巧 
    <div id="%E5%A4%A7%E6%95%B0%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%A4%A7%E6%95%B0%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>比如在上一个递归的例子中计算!50就会出现一个非常大的负数</p>
<p>问题的根源：计算机能表示的数是有范围的！</p>
<p>C#中int类型的数值占32位，是有符号的，最高一位是符号位，表示“正负”</p>
<p>正数：000……0 ~ 011……1 即 32个全“0”到 “0”+31个全“1”
负数：100……0 ~ 111……1 即“1”+31个全“0” 到 32个全“1”</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-21.png" alt="img" />
    
  </figure>

</p>
<p>类似地，long类型的数值占64位：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-22.png" alt="img" />
    
  </figure>

</p>
<p><strong>示例程序计算阶乘出现错误的原因</strong></p>
<p>由于计算机使用固定的位数来保存数值，因此，能处理的数值大小是有限的，当要处理的数值超过了这一范围时，计算机将会自动截断数值的二进制表示为它所能处理的最多位数，这将导致错误的处理结果。</p>
<p>如果我们的确需要处理很大的整数，其数值大到甚至超过了long类型的最大值263-1，是不是就没有办法了呢？</p>
<p><strong>处理巨大的整数</strong></p>
<p>.NET 基类库中提供了一个BigInteger类，支持大整数的加减乘除运算。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">BigInteger</span> <span class="n">bi</span> <span class="p">=</span> <span class="kt">long</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">;</span><span class="c1">//定义变量bi = long类型的最大值</span>
</span></span><span class="line"><span class="cl"><span class="n">bi</span> <span class="p">*=</span> <span class="m">2</span><span class="p">;</span> <span class="c1">//bi乘2</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">bi</span><span class="p">);</span> <span class="c1">//仍然正常输出</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">bi</span> <span class="p">/</span> <span class="m">4</span><span class="p">);</span>
</span></span></code></pre></div><p><strong>注意：BigInteger类型定义于System.Numerics中，需要为.NET Framework项目添加对这一程序集的引用，而.NET Core项目则可以直接使用。</strong></p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-23.png" alt="img" />
    
  </figure>

</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">50</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;!{0}={1}&#34;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">digui</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">static</span> <span class="n">BigInteger</span> <span class="n">digui</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">==</span><span class="m">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">BigInteger</span> <span class="n">ret</span> <span class="p">=</span> <span class="n">digui</span><span class="p">(</span><span class="n">x</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">*</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>浮点数的处理技巧</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0.0001</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0.00010000000000000001</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">i</span><span class="p">==</span><span class="n">j</span><span class="p">);</span>  <span class="c1">//输出：true</span>
</span></span></code></pre></div><p>计算机不能精确地表达浮点数（特殊形式的除外），因此，当需要比较两个浮点数是否相等时，应该比较其差的绝对值是否在某个允许范围之内即可，无法做到像数学那样的精确比较。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="c1">//计算两个数相减的绝对值 与 1*10的负十次方比较</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span> <span class="n">Math</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">i</span> <span class="p">-</span> <span class="n">j</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">1e-10</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;true&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;false&#34;</span><span class="p">);</span>
</span></span></code></pre></div>

<h3 class="relative group">形形色色的方法参数 
    <div id="%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">输出空格或分隔线 
    <div id="%E8%BE%93%E5%87%BA%E7%A9%BA%E6%A0%BC%E6%88%96%E5%88%86%E9%9A%94%E7%BA%BF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%BE%93%E5%87%BA%E7%A9%BA%E6%A0%BC%E6%88%96%E5%88%86%E9%9A%94%E7%BA%BF" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>在开发.NET控制台程序时，经常需要使用Console.WriteLine()方法输出信息。依据实际情况，有些时候可能希望在连续多个输出中插入一些空行，有些则希望能使用分隔线……</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-24.png" alt="img" />
    
  </figure>

</p>
<p>分隔线与空行，都需要使用单独的Console.WriteLine()语句输出，很不方便……</p>
<p>让我们编写一个函数，在输出一个字符串时，可以选择自动添加前后分隔线和空行的功能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="cs">/// </span>
</span></span><span class="line"><span class="cl"><span class="cs">/// 使用控制台输出一个字符串</span>
</span></span><span class="line"><span class="cl"><span class="cs">/// 可以选择是否在字符串前后输出由28个短划线构成的分隔线</span>
</span></span><span class="line"><span class="cl"><span class="cs">/// 或者自动追加一个空行</span>
</span></span><span class="line"><span class="cl"><span class="cs">/// </span>
</span></span><span class="line"><span class="cl"><span class="kd">static</span> <span class="k">void</span> <span class="n">PrintMessage</span><span class="p">(</span><span class="kt">string</span> <span class="n">Message</span><span class="p">,</span><span class="cs">/// 要输出的字符串</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">PrintTopDivider</span> <span class="p">=</span> <span class="kc">false</span><span class="p">,</span><span class="cs">/// 是否输出顶部分隔线</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">PrintBottomDivider</span> <span class="p">=</span> <span class="kc">false</span><span class="p">,</span><span class="cs">/// 是否输出底部分隔线</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">AppendNewLine</span> <span class="p">=</span> <span class="kc">false</span><span class="p">)</span><span class="cs">/// 是否追加一个空行</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//顶部分隔线</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">PrintTopDivider</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">new</span> <span class="kt">string</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">,</span> <span class="m">28</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//输出信息本身</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">Message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//追加一个空行</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">AppendNewLine</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//底部分隔线</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">PrintBottomDivider</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">new</span> <span class="kt">string</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">,</span> <span class="m">28</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意一下PrintMessage方法定义了三个bool类型的参数，并且都给它们指定了<strong>默认值</strong>。</p>
<p>指定了默认值的方法参数，在调用时是可省的，所以又被称为“<strong>可选参数</strong>”。</p>
<p>调用PrintMessage方法时，可以传入一个或多个参数，未传入的参数，取方法定义时指定的默认值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="k">void</span> <span class="n">PrintPoem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//输出顶部分隔线，使用了可选参数特性。</span>
</span></span><span class="line"><span class="cl">    <span class="n">PrintMessage</span><span class="p">(</span><span class="s">&#34;\t   鹿柴&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//使用命名参数特性，追加一个空行，</span>
</span></span><span class="line"><span class="cl">    <span class="n">PrintMessage</span><span class="p">(</span><span class="s">&#34;\t (唐)王维&#34;</span><span class="p">,</span> <span class="n">AppendNewLine</span><span class="p">:</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//所有可选参数均为默认值，只输出字符串</span>
</span></span><span class="line"><span class="cl">    <span class="n">PrintMessage</span><span class="p">(</span><span class="s">&#34;\t空山不见人，&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">PrintMessage</span><span class="p">(</span><span class="s">&#34;\t但闻人语响。&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">PrintMessage</span><span class="p">(</span><span class="s">&#34;\t返景入深林，&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//使用命名参数特性，输出底部分隔线，再追加一个空行，</span>
</span></span><span class="line"><span class="cl">    <span class="n">PrintMessage</span><span class="p">(</span><span class="s">&#34;\t复照青苔上。&#34;</span><span class="p">,</span> <span class="n">PrintBottomDivider</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="n">AppendNewLine</span><span class="p">:</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当一个方法中有很多个参数，在调用时可以<strong>通过名字</strong>直接给特定的参数传值，而<strong>不需要</strong>按照定义时的位置顺序，这个称为“命名参数赋值特性”</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="c1">//使用命名参数，可以不按照定义顺序传值</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">distance</span> <span class="p">=</span> <span class="n">CalculateDistance</span><span class="p">(</span><span class="n">x1</span><span class="p">:</span> <span class="m">1</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="m">2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span> <span class="m">5</span><span class="p">,</span> <span class="n">y2</span><span class="p">:</span> <span class="m">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//输出：(1,5)到(2,3)的距离为:2.23606797749979</span>
</span></span><span class="line"><span class="cl"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;(1,5)到(2,3)的距离为:{distance}&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//计算平面直角坐标系中（x1,y1）与(x2,y2)两点的距离</span>
</span></span><span class="line"><span class="cl"><span class="kd">static</span> <span class="kt">double</span> <span class="n">CalculateDistance</span><span class="p">(</span><span class="kt">double</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">tempXResult</span> <span class="p">=</span> <span class="n">x2</span> <span class="p">-</span> <span class="n">x1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">tempYResult</span> <span class="p">=</span> <span class="n">y2</span> <span class="p">-</span> <span class="n">y1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Math</span><span class="p">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">tempXResult</span> <span class="p">*</span> <span class="n">tempXResult</span> <span class="p">+</span> <span class="n">tempYResult</span> <span class="p">*</span> <span class="n">tempYResult</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h4 class="relative group">可变参数 
    <div id="%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>当给一个方法参数前面添加一个params关键字时，就表示它是一个可变参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="c1">//此方法可以接收个数可变的参数,将其使用“,”分隔输出，</span>
</span></span><span class="line"><span class="cl"><span class="c1">//最后再输出一个空行</span>
</span></span><span class="line"><span class="cl"><span class="kd">static</span> <span class="k">void</span> <span class="n">PrintIntArray</span><span class="p">(</span><span class="k">params</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">numbers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="p">!=</span><span class="n">numbers</span><span class="p">.</span><span class="n">Length</span><span class="p">-</span><span class="m">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&#34;,&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>调用示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="c1">//输出：1,2,3</span>
</span></span><span class="line"><span class="cl"><span class="n">PrintIntArray</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//输出：5,6</span>
</span></span><span class="line"><span class="cl"><span class="n">PrintIntArray</span><span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">);</span>
</span></span></code></pre></div><p>可变参数的类型，必须是一维数组。</p>
<p>当方法有多种参数的时候，可变参数必须在最后面。</p>


<h4 class="relative group">“输入（in）”型方法参数 
    <div id="%E8%BE%93%E5%85%A5in%E5%9E%8B%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%BE%93%E5%85%A5in%E5%9E%8B%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>正常情况下，在方法内部，是可以修改传入参数的值的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="kd">static</span> <span class="k">void</span> <span class="n">MethodUseIn</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">number</span><span class="p">++;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//输出：101 </span>
</span></span><span class="line"><span class="cl"><span class="n">MethodUseIn</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
</span></span></code></pre></div><p>当一个参数是in类型时，在程序运行时，方法内部访问到的变量，与外部传给它的变量是同一个，其中不存在值复制的情况。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="c1">//in是c# 7.2引入的特性，强调其参数值不可改（即只读）</span>
</span></span><span class="line"><span class="cl"><span class="c1">//如果编译器发现方法内部有代码修改参数值，将报告错误</span>
</span></span><span class="line"><span class="cl"><span class="kd">static</span> <span class="k">void</span> <span class="n">MethodUseIn</span><span class="p">(</span><span class="k">in</span> <span class="kt">int</span> <span class="n">number</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//引发编译错误</span>
</span></span><span class="line"><span class="cl">    <span class="n">number</span><span class="p">++;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>推荐对于那些包容较多成员的struct变量启用in特性</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-26.png" alt="img" />
    
  </figure>

</p>
<p>如果方法参数前没有in，则方法接收到的，是外部number变量值的一个“副本”，两者是独立的变量。</p>
<p>in也有助于提高性能，因为不需要再进行一次复制的操作。对于有相当多变量的时候很有用处。</p>


<h4 class="relative group">“输出型（out）”方法参数 
    <div id="%E8%BE%93%E5%87%BA%E5%9E%8Bout%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%BE%93%E5%87%BA%E5%9E%8Bout%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>.NET基类库中，为int类型定义了一个TryParse方法，其声明如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl"><span class="c1">//尝试将一个字符串转换为整数，保存在result中，并返回true</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">bool</span> <span class="n">TryParse</span><span class="p">(</span><span class="kt">string?</span> <span class="n">s</span><span class="p">,</span> <span class="k">out</span> <span class="n">Int32</span> <span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//举例</span>
</span></span><span class="line"><span class="cl"><span class="kt">string</span> <span class="n">numberString</span> <span class="p">=</span> <span class="s">&#34;abc&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//当numberstring的值可以转换为整数时，TryParse()方法返回True</span>
</span></span><span class="line"><span class="cl"><span class="c1">//转换的结果(即那个整数)，由number变量所接收</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="kt">int</span><span class="p">.</span><span class="n">TryParse</span><span class="p">(</span><span class="n">numberString</span><span class="p">,</span> <span class="k">out</span> <span class="n">number</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;转换得到的整数为：{number}&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;{numberString}无法被转换为整数&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>与输入型参数类似，使用输出型参数时，方法内部外部代码中所访问的变量，其实是同一个。</p>
<p>out的意思其实就是“这个实参传进去了，被改变后我仍然需要让这个数<strong>再出来</strong>”</p>
<p>我们可以很方便地为自己的方法添加out关键字，如下所示：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-28.png" alt="img" />
    
  </figure>

</p>
<p>使用例如下：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-29.png" alt="img" />
    
  </figure>

</p>
<p>使用输出型参数，可以直接将特定的数据处理任务的结果直接放到“外界”指定的“存储区域”，无需进行数据的复制工作。</p>
<p>另外，out类型的方法参数，还在Deconstruct这一特性（后面介绍）中起到了关键的作用。</p>
<p><strong>输出型参数的简写</strong></p>
<p>早期版本的C#代码，在使用输出型参数时，必须在方法外部单独定义好变量，再把它们传给方法，如下所示：</p>
<pre tabindex="0"><code>string info;
int value;
InitializeOutVariable(out info, out value);
</code></pre><p>C# 7之后，可以将变量定义与方法调用“合二为一”</p>
<pre tabindex="0"><code>InitializeOutVariable(out string info, out intvalue);
</code></pre>

<h4 class="relative group">“被丢弃（discard）”的参数 
    <div id="%E8%A2%AB%E4%B8%A2%E5%BC%83discard%E7%9A%84%E5%8F%82%E6%95%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%A2%AB%E4%B8%A2%E5%BC%83discard%E7%9A%84%E5%8F%82%E6%95%B0" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>当调用包容有输出型参数的方法时，如果对于特定的参数“不感兴趣（用不到）”，可以直接传给它一个下划线：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-30.png" alt="img" />
    
  </figure>

</p>
<p>在方法调用时传入的“下划线”称为“discard”，它不是一个变量，因此，在后面不能使用它。它仅仅只是一个用于通知编译器的“标记”而己，告诉编译器：“这个参数后面没有用到”。</p>


<h3 class="relative group">本地方法 
    <div id="%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>本地方法，是指那些定义在一个方法内部的方法，它们仅在方法<strong>内部使用</strong>，不能被外部方法所调用。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-31.png" alt="img" />
    
  </figure>

</p>
<p>本地方法可以访问并修改外部方法的本地变量</p>
<p>doSomething方法执行完毕之后，它对value变量的修改仍然是生效的。</p>
<p><strong>闭包（closure）：</strong></p>
<p>一个本地方法使用了外部定义的变量，它与它所访问的变量构成一个闭包。当其执行结束之后，方法对外部变量的修改结果可以保存。</p>


<h4 class="relative group"><strong>静态本地方法</strong> 
    <div id="%E9%9D%99%E6%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%9D%99%E6%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-32.png" alt="img" />
    
  </figure>

</p>
<p>使用静态本地方法，可以避免创建内部匿名类型实例的开销，付出的代价就是它不能访问外部方法中所定义的局部变量，这让其的使用场景受限。</p>


<h4 class="relative group">本地方法的应用示例-1 
    <div id="%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B-1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B-1" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-33.png" alt="img" />
    
  </figure>

</p>
<p>通过将特定的功能代码封装为本地方法，可以让代码更为易读，因为本地方法实际上干的事情，就是将代码 “<strong>分块打包</strong>”。</p>
<p>将所有计数相关的代码都打包为一个整体。
注意，这是一个“<strong>递归</strong>”的本地方法。</p>


<h4 class="relative group">本地方法的应用示例-2 
    <div id="%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B-2" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B-2" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-34.png" alt="img" />
    
  </figure>

</p>
<p>方法体中出现了重复的代码，可以将其抽取为本地方法，以便消除这些重复的代码。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-35.png" alt="img" />
    
  </figure>

</p>


<h4 class="relative group">本地方法的应用示例-3 
    <div id="%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B-3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B-3" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-36.png" alt="img" />
    
  </figure>

</p>
<p>因为使用了本地方法将相关代码“分块”打包，并且起了易懂的名字，现在你看这个包容有数十行代码的方法，它要干的事情是不是特别地清楚，只需要扫一眼就知道了？</p>


<h4 class="relative group">小结： 
    <div id="%E5%B0%8F%E7%BB%93" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%B0%8F%E7%BB%93" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>当你发现一个方法中包容太多的代码，或者是这些代码包容着非常类似的大同小异的逻辑，就可以使用本地方法将其重构。从而让代码易读且逻辑清晰。</p>
<p>本地方法不能被外界调用，很好地贯彻了信息隐藏的原则。</p>


<h2 class="relative group">Windows Forms软件开发技术基础 
    <div id="windows-forms%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#windows-forms%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">使用Visual Studio编写GUI程序 
    <div id="%E4%BD%BF%E7%94%A8visual-studio%E7%BC%96%E5%86%99gui%E7%A8%8B%E5%BA%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BD%BF%E7%94%A8visual-studio%E7%BC%96%E5%86%99gui%E7%A8%8B%E5%BA%8F" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">什么叫“GUI”程序？ 
    <div id="%E4%BB%80%E4%B9%88%E5%8F%ABgui%E7%A8%8B%E5%BA%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BB%80%E4%B9%88%E5%8F%ABgui%E7%A8%8B%E5%BA%8F" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>GUI = Graphic User Interfce（图形用户界面接口）</p>
<p>GUI程序就是拥有“可以看得见”的窗体的应用程序，你可以使用鼠标和键盘去操作它，我们日常所用的Word、QQ之类，都属于这个类别。</p>
<p>这种程序，通常对应着一个“图标（icon）”，人们习惯于将常用的应用程序的图标摆放到Windows的桌面上，因此，人们又将它们称为“桌面应用”。</p>
<p>两种类型的桌面应用：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-37.png" alt="img" />
    
  </figure>

</p>


<h4 class="relative group">VS2019编写 GUI程序 的技巧 
    <div id="vs2019%E7%BC%96%E5%86%99-gui%E7%A8%8B%E5%BA%8F-%E7%9A%84%E6%8A%80%E5%B7%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#vs2019%E7%BC%96%E5%86%99-gui%E7%A8%8B%E5%BA%8F-%E7%9A%84%E6%8A%80%E5%B7%A7" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>不同的项目类型有不同的应用场景，要用C#开发桌面应用，选择“Windows窗体应用程序”这个项目模板。</p>
<p>注意：Windows窗体应用程序（简称WinForms）有两种运行环境，.NET Framework与.NET Core，新写的程序建议使用.NET Core的。</p>
<p><strong>关于代码的折叠：</strong></p>
<pre tabindex="0"><code>#region btnSayHelloWorld点击
private void button1_Click(object sender, EventArgs e)
{
    MessageBox.Show(&#34;Hello World!&#34;);
}
#endregion
</code></pre><p><strong>窗体文件的构成：</strong></p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-40.png" alt="img" />
    
  </figure>

</p>
<p><strong>关于：有两个窗体时程序运行如何默认打开第二个</strong></p>
<p>在Program.cs内修改：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-38.png" alt="img" />
    
  </figure>

</p>
<p><strong>关于：自定义程序的图标</strong></p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-39.png" alt="img" />
    
  </figure>

</p>
<ul>
<li>“文件”放在“项目”中，项目归“解决方案”管。</li>
<li>编译之后，项目生成一个EXE文件，在放在项目的 /bin目录下。</li>
</ul>
<p><strong>扩充知识：RAD（快速应用开发）模式</strong></p>
<p>使用Visual Studio编写桌面应用程序，具有 “<strong>所见即所得</strong>（WYSIWYG：What You See Is What You Get）”的特点，这种开发方式，被称为“<strong>RAD</strong>（Rapid Application Development）”。</p>
<p>采用RAD方式开发，软件用户能很快地看到可以一个可以跑起来的程序从而给出他的意见，这样一来，软件开发者就能尽早了解到软件是否符合用户的需求，及时调整，开发出“真正满足用户需要”的软件。</p>
<p>RAD开发方式，最适合于规模小，功能简单的带有“演示”性质的程序。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-41.png" alt="img" />
    
  </figure>

</p>


<h3 class="relative group">常见WinForm控件的使用方法 
    <div id="%E5%B8%B8%E8%A7%81winform%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%B8%B8%E8%A7%81winform%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">按钮控件 
    <div id="%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>“按钮（Button）”是一个“控件（Control）”，它拥有这样的特性：</p>
<ol>
<li>当用户用鼠标点击时，触发一个Click事件，如果程序员事先为这个Click事件写好了代码，那么这些代码将被计算机执行。</li>
<li>如果用户始终没有用鼠标点击按钮，Click事件将不会触发，对应的，程序员事先为这个Click事件写好的代码也永无被被计算机执行的机会。</li>
</ol>
<p>以上为 事件驱动的程序运行方式</p>
<p>按钮的图片：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-42.png" alt="img" />
    
  </figure>

</p>


<h4 class="relative group">标签控件 
    <div id="%E6%A0%87%E7%AD%BE%E6%8E%A7%E4%BB%B6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%A0%87%E7%AD%BE%E6%8E%A7%E4%BB%B6" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-43.png" alt="img" />
    
  </figure>

</p>
<p>设置BackColor属性值为Transparent，标签将不带有背景颜色。</p>
<p>在程序中使用标签动态显示信息：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-44.png" alt="img" />
    
  </figure>

</p>
<p>编程要点：控件名字与事件</p>
<ul>
<li>放在窗体上的每个控件都是对应控件类的对象，其中，最关键的是它的名字（即Name属性）！</li>
<li>在代码中，通过指定控件的名字来设定它的属性值。</li>
<li>控件会触发特定的事件，我们可以为这些事件编写事件响应代码，当事件真的发生时，这些响应代码被调用，这就是“事件驱动”的编程模式。</li>
</ul>


<h4 class="relative group">文本框控件 
    <div id="%E6%96%87%E6%9C%AC%E6%A1%86%E6%8E%A7%E4%BB%B6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%96%87%E6%9C%AC%E6%A1%86%E6%8E%A7%E4%BB%B6" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>文本框控件主要用于供用户输入，它是TextBox类的对象</p>
<p>问：怎样得到用户输入的字符串？
答：使用它的Text属性</p>
<p>问：如何即时响应用户的输入？
答：响应它的TextChanged事件</p>
<pre tabindex="0"><code>private void txtUserInput_TextChanged(object sender, EventArgs e)
{
    lblShowInput.Text = txtUserInput.Text;
}
</code></pre><p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-47.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-45.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-46.png" alt="img" />
    
  </figure>

</p>
<p>在事件名上右击，选“重置” 命令，可以移除本事件的响应代码</p>
<p><strong>需要牢记：</strong></p>
<p>特定的控件，在不同的场景，会触发不同的事件。</p>
<p>在实际开发中，必须特别注意以下三点：</p>
<ol>
<li>控件触发了哪些事件？</li>
<li>这些事件触发的顺序是怎么样的？</li>
<li>我选择哪些事件进行响应？</li>
</ol>


<h4 class="relative group">进度条控件与小闹钟控件 
    <div id="%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%8E%A7%E4%BB%B6%E4%B8%8E%E5%B0%8F%E9%97%B9%E9%92%9F%E6%8E%A7%E4%BB%B6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%8E%A7%E4%BB%B6%E4%B8%8E%E5%B0%8F%E9%97%B9%E9%92%9F%E6%8E%A7%E4%BB%B6" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>进度条：</p>
<ul>
<li>Maximum（最大值）与 Minimum（最小值）</li>
<li>Value（当前值）：当Value=Maximum时，进度条满格</li>
</ul>
<p>一个进度条，点击旁边的按钮会使其进度+10，满了之后会清空</p>
<pre tabindex="0"><code>private void btnjia_Click(object sender, EventArgs e)
{
    if(progressBar1.Value + 10 &gt; progressBar1.Maximum)
    {
        progressBar1.Value = progressBar1.Minimum;
    }
    else
    {
        progressBar1.Value += 10;
    }
}
</code></pre><p>时钟控件：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-48.png" alt="img" />
    
  </figure>

</p>


<h4 class="relative group">个人实例练习： 
    <div id="%E4%B8%AA%E4%BA%BA%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%AA%E4%BA%BA%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>时钟软件 <a href="https://lingyun67.cn/alarm-clock-demo/"   target="_blank">
    https://lingyun67.cn/alarm-clock-demo/</a></p>


<h3 class="relative group">使用容器控件布局窗体（WinForm） 
    <div id="%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E6%8E%A7%E4%BB%B6%E5%B8%83%E5%B1%80%E7%AA%97%E4%BD%93winform" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E6%8E%A7%E4%BB%B6%E5%B8%83%E5%B1%80%E7%AA%97%E4%BD%93winform" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-50.png" alt="img" />
    
  </figure>

</p>


<h4 class="relative group">控件的通用属性 
    <div id="%E6%8E%A7%E4%BB%B6%E7%9A%84%E9%80%9A%E7%94%A8%E5%B1%9E%E6%80%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%8E%A7%E4%BB%B6%E7%9A%84%E9%80%9A%E7%94%A8%E5%B1%9E%E6%80%A7" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>控件的激活与禁用：Enabled属性，通过设置其值为True或False，可以激活或禁用特定的控件。</p>
<p>显示与隐藏：visible属性</p>
<p>Anchor属性：响应窗口的大小改变</p>
<p>Dock：黄色的是容器 Dock属性设置之后 按钮会按选项分布在背板上面</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-51.png" alt="img" />
    
  </figure>

</p>


<h4 class="relative group">控件容器 
    <div id="%E6%8E%A7%E4%BB%B6%E5%AE%B9%E5%99%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%8E%A7%E4%BB%B6%E5%AE%B9%E5%99%A8" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>控件容器是一种特殊的控件，它可以容纳多个“子”控件。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-52.png" alt="img" />
    
  </figure>

</p>
<p>我们己经非常熟悉的“窗体（Form）”，就可以看成是一个容器控件，只不过它是“顶层容器”。</p>
<p>注意：“顶层容器”无法再放入另一个“顶层容器”中。</p>
<p><strong>最简单的容器控件——面板（Panel）</strong></p>
<p>面板中可以放置其他控件，甚至再嵌套一个面板。</p>
<p>使用面板，可以把它所包容的所有控件看成是一个整体，统一地控制它们（比如激活或禁用它们）。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-53.png" alt="img" />
    
  </figure>

</p>
<p><strong>组合框（ GroupBox ）</strong></p>
<p>组合框功能与面板类似，仅在外观上有所区别。</p>
<p>组合框拥有一个标题和边界，在实际开发中多用于给控件分组。</p>
<p>特别地，当需要在窗体上放置独立的几组“单选钮”时，就可以将它们放在分组框中。</p>
<p><strong>选项卡控件（TabControl）</strong></p>
<p>选项卡控件（或称为多页面控件）能够充分重用有限的屏幕空间，在运行时由用户选择显示哪一组控件。</p>
<p>在程序运行时，我们可以动态地添加或移除选项卡，激活特定的选项卡，在需要的时候，也可以动态地向特定选项卡中添加或移除控件。</p>
<p>设计时添加与移除选项卡：TabControl的TabPages属性包容所有选项卡对象</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-54.png" alt="img" />
    
  </figure>

</p>
<p>在设计时可以使用集合编辑器添加或移除选项卡。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/04/image-55.png" alt="img" />
    
  </figure>

</p>
<p><strong>分隔条面板（SplitContainer）</strong></p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-1.png" alt="img" />
    
  </figure>

</p>
<p><strong>FlowLayout控件布局容器</strong></p>
<p>可以动态地添加与移除控件到FlowLayout中，由它负责排列控件。</p>
<p>使用FlowLayout称为“流式布局”，类似于Web网页布局方式，默认情况下，从左到右，从上到下排列其子控件，如果“自动换行（WrapContents）”特性打开，一行摆放不下时，会到下一行排列。如果打开了“自动滚动（AutoScroll）”特性，会在合适时候自动地添加水平或垂直滚动条</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-2.png" alt="img" />
    
  </figure>

</p>
<p><strong>TableLayoutPanel</strong></p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-3.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-4.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-5.png" alt="img" />
    
  </figure>

</p>


<h2 class="relative group">———— C#面向对象编程入门篇———— 
    <div id="-c%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AF%87" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#-c%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AF%87" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h2 class="relative group">类和对象（C#） 
    <div id="%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1c" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1c" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">⭐理解类和对象的概念 
    <div id="%E7%90%86%E8%A7%A3%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%90%86%E8%A7%A3%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-6.png" alt="img" />
    
  </figure>

</p>
<p>“主窗体”和“从窗体”都是窗体，但“地位”不一样。主窗体一关闭，整个程序结束、从窗体关闭，整个程序仍然会继续运行。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-7.png" alt="img" />
    
  </figure>

</p>
<p>用<strong>frmOther类型的变量frm</strong>来保存new出来的frmOther的对象的<strong>引用</strong></p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-8.png" alt="img" />
    
  </figure>

</p>


<h3 class="relative group">学会编写类 
    <div id="%E5%AD%A6%E4%BC%9A%E7%BC%96%E5%86%99%E7%B1%BB" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AD%A6%E4%BC%9A%E7%BC%96%E5%86%99%E7%B1%BB" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>所有代码放在类中，类是编程的基本单元。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-9.png" alt="img" />
    
  </figure>

</p>
<p>一个.cs文件包含多个类</p>
<p>C# 9.0之后，代码可以不放到类中，这是C#引入函数式编程特性的结果。</p>
<p>C#使用class关键字定义一个类。类中常见的成员有：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-10.png" alt="img" />
    
  </figure>

</p>
<p>字段和方法组合起来起个名字，就变成了类</p>
<p>C#中的字段与方法，可以加上“<strong>public</strong>、<strong>private</strong>、 <strong>protected</strong>”关键字控制其存取权限。</p>
<p>（公有的、私有的、被保护的）</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-11.png" alt="img" />
    
  </figure>

</p>
<p>需要注意的是：在方法体内定义的j是局部变量，类中的同名j是失效的（变量的屏蔽原则）</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-12.png" alt="img" />
    
  </figure>

</p>
<ol>
<li>类中的方法，可以直接访问类中的字段。</li>
<li>类中的方法定义的局部变量，将屏蔽掉类中的同名字段。</li>
<li>有两种最基本的数据存取权限：</li>
</ol>
<ul>
<li><strong>public（公有）</strong>：通过对象变量外界可以直接访问它</li>
<li><strong>private（私有）</strong>：除了类内部的方法，外界无法直接访问它们</li>
</ul>
<p>实践建议：在设计一个类时，仅仅只有需要被外界访问的成员才设置为public的。</p>


<h4 class="relative group">类的“属性（property）” 
    <div id="%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7property" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7property" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>字段+get/set方法=属性</p>
<pre tabindex="0"><code>public class MyTestClass 
{
    //私有变量用于存储数据
    private string _myprop = &#34;&#34;;
    public string Myprop
    {
        get //读访问器
        {
            return _myprop;
        }
        set /写访问器
        {
            _myprop = value;
            //value是一个拥有特殊含义的关键字，在此处，它代表外界传入的值。
        }
    }
}
</code></pre><p>使用例：</p>
<pre tabindex="0"><code>MyTestClass obj = new MyTestClass(); //向属性赋值
obj.Myprop = &#34;Hello&#34;;
//读取属性值
Console.WriteLine(obj.Myprop); 
</code></pre><p>实现自定义属性的要点：</p>
<ol>
<li>定义一个<strong>私有</strong>字段用于存储属性数据。</li>
<li>设计一个<strong>get</strong>方法，当读取属性值时，向外界返回私有字段的当前值。</li>
<li>设计一个<strong>set</strong>方法，当向属性赋值时，其自动隐含的value参数保存外界传入的值，应将此值传给前面定义的私有字段。</li>
</ol>
<p>属性的经典实现方法的弊端：</p>
<p>当一个类中存在有很多的属性，而这些属性又采用类似的方法编写时，这是一个烦人的工作，要敲很多的代码！</p>
<p>C# 3.0的改进——自动实现的属性</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-13-1024x478.png" alt="img" />
    
  </figure>

</p>
<p><strong>“属性”比“字段”多了哪些东西？</strong></p>
<pre tabindex="0"><code>//人的年龄只能是一个正数，因此，当外界传入一个负数时，set方法会自动将其改为0。
public class Person
{
    private int _age = 0;
    public int Age
    {
        get
        {
            return _age;
        }
        set
        {
            if(value &lt; 0)
            {
                _age = 0;
            }
            else
            {
                _age = value;
            }
        }
    }
}
</code></pre><p>当使用经典写法时，我们可以很容易地在读/写属性时“插入一些”特定的代码，完成诸如“检验数据”、“显示信息”、“触发事件”等工作，这是单纯的字段所不具备的特性。</p>
<p>定义一个属性时，get/set方法并不需要同时存在，它们的存取权限也可以不一样，各种情况的不同组合，将影响到属性的存取特性……</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-14.png" alt="img" />
    
  </figure>

</p>
<p>开发建议</p>
<p>在实际开发中，多用属性少用字段，尤其是杜绝“<strong>公有（public）</strong>”字段，因为过多的公有字段，向外部暴露了内部的数据结构，外界可以随意修改它，有可能引发开发者意料之外的Bug，损害了代码的健壮性和可维护性。</p>
<p><strong>表达式体属性（Expression-bodied property）</strong></p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-15-1024x435.png" alt="img" />
    
  </figure>

</p>
<p>注意区分：</p>
<pre tabindex="0"><code>定义一个只读的属性：
public int Foo =&gt; 0;
定义一个可读可写的公有字段：
public int Foo = 0;
</code></pre><p><strong>表达式体方法（Expression-bodied method）</strong></p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-16.png" alt="img" />
    
  </figure>

</p>
<p>表达式体方法和属性，统称为“表达式体成员（Expression-bodied Member）”，这些特性从C# 6开始引入，以后版本不断地完善。</p>
<p>“表达式体成员”是个语法糖，它与后面课程要介绍Lambda表达式，虽然样子很像，但不是一回事，注意区分。</p>


<h3 class="relative group">类的初始化过程 
    <div id="%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>当我们通过new关键字创建一个对象时，一个特殊的函数被调用，此函数被称为——<strong>构造函数（构造方法）</strong>。</p>
<pre tabindex="0"><code>MyClass obj = new MyClass();
</code></pre><p>所谓“构造方法”，就是在创建对象时被自动调用的方法。</p>
<p>构造方法长成什么样？：</p>
<p>构造方法与类名相同，没有返回值。</p>
<pre tabindex="0"><code>public class MyClass
{
    public MyClass()
    {
        Console.WriteLine(&#34;无参数构造方法被调用&#34;);
    }
    public MyClass(string info)
    {
        Console.WriteLine(&#34;调用MyClass(string):&#34; + info);
    }
}
</code></pre><p>一个类可以有多个构造方法，这些构造方法构成“重载（overload）” 关系。在程序实际运行时，依据参数决定调用哪个构造方法。</p>
<pre tabindex="0"><code>static void Main(string[] args)
{
    //这样可以调用无参构造方法
    MyClass obj = new MyClass();

    //这样可以调用有字符串参数的构造方法
    obj = new MyClass(&#34;Hello world!&#34;);
}
</code></pre><p>构造方法主要用于在创建对象时给它的相关字段一个有意义的初始值。</p>
<p>定义一个类时，即使你没有显式地定义一个构造方法，C#编译器也会“偷偷”地给你的类加上一个没有参数的“<strong>缺省（或称为默认）构造方法</strong>”。</p>
<p><strong>创建对象并给其字段/属性相应初始值的基本方法</strong></p>
<pre tabindex="0"><code>public class MyClass
{
    public int IntValue;
    public string StrValue
    {
        get;
        set;
    }
}
</code></pre><p>以下代码创建MyClass的对象并给其字段或属性赋值：</p>
<pre tabindex="0"><code>static void Main(string[] args)
{
    MyClass obj = new MyClass();

    obj.IntValue = 100;
    obj.StrValue = &#34;Hello world!&#34;;
}
</code></pre><p>当一个类定义了多个字段或属性时，代码变得很冗长……</p>
<p>改进方式一：给类添加构造函数</p>
<pre tabindex="0"><code>public class MyClass
{
    public int IntValue;
    public string StrValue
    {
        get;
        set;
    }

    //给类添加构造函数
    public MyClass(int iValue, string strValue)
    {
        IntValue = iValue;
        StrValue = strValue;
    }
}
</code></pre><p>使用代码：</p>
<pre tabindex="0"><code>MyClass obj = new MyClass ( 100 , &#34;Hello&#34; );
</code></pre><p>但是存在的问题就是如果我只想给部分属性和字段一个有效的初始值，需要提供多个重载的构造函数。这就让类的定义变得复杂了。</p>
<p>改进方式二：使用C#3.0所提供的“对象初始值设定项”特性，不需要给MyClass添加重载的构造函数即可实现相同目的：</p>
<p>类的原始定义不变</p>
<pre tabindex="0"><code>public class MyClass
{
    public int IntValue;
    public string StrValue
    {
        get;
        set;
    }
}
</code></pre><p>简化后的字段/属性初始化代码</p>
<pre tabindex="0"><code>//对象字段和属性直接使用其默认值
MyClass obj1 = new MyClass();

//设定对象所有的字段和属性初始值
MyClass obj2 = new MyClass
{
    IntValue = 100,
    StrValue = &#34;Hello&#34;
};

//设定对象部分的字段和属性初始值
MyClass obj3 = new MyClass
{
    IntValue = 100
};
</code></pre><p>还可以直接初始化集合对象</p>
<p>直接初始化基本数据类型的集合对象</p>
<pre tabindex="0"><code>List digits = new List { 0, 1, 2, 3, 4, 5, 6 }; 
</code></pre><p>初始化包含引用类型元素的集合对象</p>
<pre tabindex="0"><code>List objs = new List{
    new MyClass{ IntValue=100,StrValue=&#34;Hello&#34;},
    new MyClass{ IntValue=200,StrValue=&#34;World&#34;}
}; 
</code></pre>

<h3 class="relative group">类的组织与管理 
    <div id="%E7%B1%BB%E7%9A%84%E7%BB%84%E7%BB%87%E4%B8%8E%E7%AE%A1%E7%90%86" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%B1%BB%E7%9A%84%E7%BB%84%E7%BB%87%E4%B8%8E%E7%AE%A1%E7%90%86" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">分部类与分部方法 
    <div id="%E5%88%86%E9%83%A8%E7%B1%BB%E4%B8%8E%E5%88%86%E9%83%A8%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%88%86%E9%83%A8%E7%B1%BB%E4%B8%8E%E5%88%86%E9%83%A8%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>分部类（partial class）:</p>
<p>把同一个类的代码分散到多个文件中</p>
<p>分部方法（partial method）:</p>
<p>在一个文件中声明方法，在另一个文件中实现或调用方法</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-17-1024x579.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-18.png" alt="img" />
    
  </figure>

</p>
<p>分部方法与分部类的应用实例:</p>
<ul>
<li>在.NET中，Windows Forms和WPF都使用了分部类将“自动生成”的代码与程序员“手工编写”的代码分隔开来。</li>
<li>在实际开发中，我们可以使用分部类将不同程序员对同一个类的修改 “隔离”开来，提升代码的可维护性。</li>
<li>利用分部方法，我们可以预先定义好一些“扩展点”（有点类似于在自习室用书本占座），然后在需要这些扩展点发挥作用时，提供其实现代码（人到自习室了），从而在源代码级别让系统易于扩展（无需修改原有代码，即可实现新的特性）。</li>
</ul>


<h4 class="relative group">命名空间 
    <div id="%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>把类比作书的话，命名空间就是书架</p>
<p>命名空间（namespace）：可以看成是类的仓库，.NET中所有的功能都由类提供，这些类被分门别类地存放在特定的命名空间中。</p>
<p>有单独的命名空间</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-19.png" alt="img" />
    
  </figure>

</p>
<p>也有多层嵌套的命名空间</p>
<p>要点：</p>
<ul>
<li>类放在命名空间中</li>
<li>命名空间可以嵌套</li>
</ul>
<p>在C#中创建和使用命名空间：</p>
<p>C#中使用namespace关键字来定义命名空间</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-20.png" alt="img" />
    
  </figure>

</p>
<p>使用using语句来引用命名空间的类</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-21.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-22.png" alt="img" />
    
  </figure>

</p>
<p>使用“对象浏览器”</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-23.png" alt="img" />
    
  </figure>

</p>
<p>命名空间在“对象浏览器” 中使用“｛｝”展示程序集中的命名空间及其包容的类型</p>
<p>C# 6中的简化</p>
<p>对于一些完整名字很长的类型，可以通过提前“静态导入”的方式，大大缩短其长度，从而允许在代码直接写上方法名。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-24.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-25.png" alt="img" />
    
  </figure>

</p>


<h3 class="relative group">程序集 
    <div id="%E7%A8%8B%E5%BA%8F%E9%9B%86" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%A8%8B%E5%BA%8F%E9%9B%86" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>如果把程序集比作砖块，那么应用程序就是建筑物</p>
<p>关于“程序集”应该知道的……：</p>
<ol>
<li>.NET程序的基本构造块是“程序集（Assembly）”。</li>
<li>程序集是一个扩展名为.dll或.exe的文件。</li>
<li>.NET 中的各个类，存放在相应的程序集文件中。</li>
</ol>
<p>如何创建一个程序集？</p>
<p>“类库（class library）”项目模板可以用于创建一个DLL程序集</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-26.png" alt="img" />
    
  </figure>

</p>
<p>使用程序集</p>
<p>在一个新项目中添加对于特定程序集的“引用（Reference）”，即可使用此程序集中的类：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-27.png" alt="img" />
    
  </figure>

</p>
<p>程序集与命名空间的关系</p>
<ol>
<li>程序集的物理载体是“实实在在可以看得到”的.dll或.exe文件。</li>
<li>命名空间是类的一种组织方式，它是一个逻辑上的概念。一个命名空间中的类可以分布在多个程序集文件中。</li>
<li>一个程序集至少包含一个命名空间。可以在项目的“属性”面板中直接指定其生成的程序集默认的命名空间（如下图所示）。</li>
</ol>
<p>基于程序集开发</p>
<ul>
<li>通过将需要复用的代码放到类库项目中，生成二进制的.dll程序集文件，然后在新项目中直接引用此.dll文件，即可以使用其中的类。</li>
<li>使用程序集构造软件不需要有类的源代码，有.exe和.dll文件即可。</li>
<li>象程序集这种可以复用的软件系统构造单元，被称之为“<strong>软件组件</strong>”。</li>
</ul>
<p>在早期的.NET程序中，通常都是直接引用本地程序集的物理文件（.dll或.exe）来重用其内部的代码，后来，为了方便组件的跨互联网重用，以及解决版本管理和组件间依赖的问题，引入了一种新的组件——Nuget包，并且慢慢地成为了主流。
有关Nuget包的相关介绍，参看“.NET Core 软件开发技术导论与自学指南”课程中的相关章节。</p>
<p>积木式的软件开发方式</p>
<p>基于程序集，可以方便地在.NET平台上实现组件化开发，其具体过程为：</p>
<ol>
<li>重用已有的组件</li>
<li>开发部分新的组件</li>
<li>将新老组件合在一起“搭积木”。</li>
</ol>
<p><strong>从现在开始，当开发正式的项目时，都应该采用基于程序集的开发方式！</strong></p>


<h2 class="relative group">“对象”与“对象变量”那些事儿 
    <div id="%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">对象与对象变量 
    <div id="%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">对象变量与内存模型 
    <div id="%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>“对象变量”与“对象”之间的关系……</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-28.png" alt="img" />
    
  </figure>

</p>
<p>对象生存于**托管堆（Managed Heap）**中，当不用时，CLR会自动回收其内存。</p>
<p>CLR中有一个垃圾回收的一个线程，在合适的时候他会运行，检查哪些对象已经不再使用然后回收其所占用的内存</p>
<p>对象生成的这块区域：托管堆的管理不是程序员负责，是由虚拟机 CLR负责</p>
<p>方法中所定义的对象变量保存在**线程堆栈（Thread Stack）**中，这两者是不一样的</p>
<p><strong>线程堆栈 vs. 托管堆</strong></p>
<ol>
<li>程序代码其实是由线程负责执行的，每个线程都拥有一个用于保存临时数据的特定内存区域，称为**“线程堆栈（Thread Stack）”。**</li>
<li>保存在线程堆栈中的数据，当它所关联的线程运行结束时，这个线程堆栈会被销毁，导致其中的数据“全没了”。</li>
<li>保存在托管堆中的数据，只有当整个程序结束时，才会被全部“销毁”。</li>
</ol>
<p><strong>C#中的两种主要的变脸类型：引用类型 vs. 值类型</strong></p>
<p>“类”类型的变量属于“引用类型（Reference Type）”，其引用的对象占用的内存位于“托管堆（managed heap）”中。</p>
<p>int之类简单类型（还包括struct等）的变量属于“值类型（Value Type）”，方法内部所定义的值类型的变量，其占用的内存位于“线程堆栈（thread stack）”中。</p>
<p>一个思考：假设MyClass是一个类，请看以下C#代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">MyClass</span> <span class="n">obj1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyClass</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">MyClass</span> <span class="n">obj2</span> <span class="p">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">obj2</span> <span class="p">=</span> <span class="n">obj1</span><span class="p">;</span>
</span></span></code></pre></div><p>上述代码执行之后，obj1和obj2引用的是两个不同的对象吗？</p>
<p><strong>对象变量“相互赋值”的真实含义</strong></p>
<p>首先会在托管堆中new一个MyClass对象，紧接着定义好了一个对象变量obj1，这个对象变量负责引用这个MyClass对象，对象变量obj1的内存区域保存的是MyClass对象在<strong>托管堆中的地址值</strong>。</p>
<p>可以说对象变量obj1是一块用来保存地址的存储区域</p>
<p>第二句 MyClass obj2 = null; 定义了一个新的对象变量obj2=null，null是一个特殊值，表示obj2是一个空引用</p>
<p>当obj1赋值给obj2，obj1没有改变</p>
<p>要注意的是，对象变量的赋值其实是对象变量所关联的内存区域<strong>地址的值复制</strong></p>
<p>赋值之后obj2和obj1的保存的值是一样的，所以他们引用相同的对象，在全部过程中，MyClass对象都只有一个。</p>


<h3 class="relative group">对象判等 
    <div id="%E5%AF%B9%E8%B1%A1%E5%88%A4%E7%AD%89" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AF%B9%E8%B1%A1%E5%88%A4%E7%AD%89" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>一段代码：</p>


<h4 class="relative group">两个值类型变量的判等 
    <div id="%E4%B8%A4%E4%B8%AA%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%A4%E7%AD%89" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%A4%E4%B8%AA%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%A4%E7%AD%89" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>int i = 100;
int j = 100;
Console.WriteLine(i  j);
//int类型内的Equals方法
Console.WriteLine(i.Equals(j));
</code></pre><p>int类型其实是一个结构体，这个结构体里是.NET基类库在程序集mscorlib中封装的基本的数据类型，是int32，其中有很多相应方法，比如Equals</p>
<p>Equals方法的摘要是比对int32这个结构体里面的数值是否是一样的，返回一个bool类型</p>
<p>这段代码运行的结果是两个True</p>
<p>另一段代码：</p>


<h4 class="relative group">两个对象的判等 
    <div id="%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A4%E7%AD%89" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A4%E7%AD%89" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>MyClass obj1 = new MyClass();
MyClass obj2 = new MyClass();
Console.WriteLine(obj1  obj2);
Console.WriteLine(obj1.Equals(obj2));
</code></pre><p>这个Equals方法与之前的来源不同，这个方法来自object类型</p>
<p><strong>当定义一个类的时候，没有指明他的基类库，那么他的基类库默认为Object。</strong></p>
<p><em>基类库的作用是完成框架的通用性开发而必须的基础类和常用工具类等</em></p>
<p>代码的输出结果是两个False，这表明obj1与obj2引用了两个不同的对象，他们内存的地址不同equals方法默认的功能和一样，但有的时候我们希望比对两个对象的字段值（按照内容进行比较而不是按照引用来比较）</p>
<p>此时就需要重写基类的equals方法</p>
<pre tabindex="0"><code>class MyClass
{
    private int Vaule = 100;

    public override bool Equals(object obj)
    {
        //如果要比较的这个对象是空引用那么直接返回false
        if (obj  null)
        {
            return false;
        }
        else
        {
            //如果传入的这个参数也是MyClass对象
            if(obj is MyClass)
            {
                //obj as MyClass把这个参数转变为MyClass的类型变量然后取出来其值然后进行对比返回bool
                return this.Vaule  (obj as MyClass).Vaule;
            }
        }
        return false;
    }

    //在.NET规定如果重写了object的Equals方法那必须也对这个GetHashCode()覆写
    public override int GetHashCode()//主要目的是为了让对象放在一些以哈希值作为定位的集合中也能正常运作
    {
        return Vaule;
    }
    //这个方法有一个基本要求就是当我们的字段值不一样的时候它的返回值一定要不同（？
}
</code></pre><p>在MyClass内对Equals进行override</p>
<p>代码运行后输出的是False True</p>
<p>因为第二次的比对使用覆写的Equals方法判断的是字段值</p>
<p><em>override 方法：<strong>提供从基类继承的成员的新实现</strong> 也就是覆写 重写</em></p>


<h4 class="relative group">两个字符串的判等 
    <div id="%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A4%E7%AD%89" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A4%E7%AD%89" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>string str1 = &#34;Hello&#34;;
string str2 = &#34;Hello&#34;;
Console.WriteLine(str1  str2);
Console.WriteLine(str1.Equals(str2));
</code></pre><p>代码输出的是两个true</p>
<p>注意：string类型是引用类型，但是它的等于号和Equals方法是一样的，都是判断这两个字符串的值是否是一样的</p>
<p>string类型 对判等运算符 进行了重写</p>
<p>注意：此处的结论仅<strong>适用于C#</strong>，另外的编程语言比如Java，仍然严格区分string类型的和Equals方法，比较对象引用，Equals比较对象内容。</p>


<h4 class="relative group">结论： 
    <div id="%E7%BB%93%E8%AE%BA" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BB%93%E8%AE%BA" aria-label="锚点">#</a>
    </span>        
    
</h4>
<ol>
<li>当“”运算符施加于两个<strong>值类型</strong>变量时，实际上是比对两个变量的<strong>内容</strong>（值）是否一样。</li>
<li>当“”运算符施加于两个<strong>引用类型</strong>变量时，实际上是比对这两个变量是否引用同一对象！</li>
<li>要“按值比较”对象，需重写其**Equals()<strong>和</strong>GetHashCode()**方法。</li>
<li>String是引用类型，但它的“”经过了重写，其功能与“Equals()”方法一样，都是比较两个字符串的“内容”是否一样</li>
</ol>
<p>另一个比较对象引用的方法：</p>
<p>.NET Core和.NET Framework中，都为Object类（它是所有.NET类的最顶层基类）定义了一个ReferenceEquals()方法，可以使用这个方法来比对任意两个对象变量是否引用同一个对象。</p>
<pre tabindex="0"><code>static void objectReferenceDemos()
{
    var a = new MyClass();
    var b = new MyClass();

    Console.WriteLine(object.ReferenceEquals(a,b));//False
    b = a;
    Console.WriteLine(object.ReferenceEquals(a,b));//True

    var str1 = &#34;abc&#34;;
    var str2 = new string(new char[] { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; });
    //False
    Console.WriteLine(object.ReferenceEquals(str1,str2));
    //True
    Console.WriteLine(object.ReferenceEquals(str1,&#34;abc&#34;));
}
</code></pre>

<h3 class="relative group">this引用 
    <div id="this%E5%BC%95%E7%94%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#this%E5%BC%95%E7%94%A8" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>类的实例方法可以直接访问同一个类的实例字段，其中隐藏着一个this引用</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-29.png" alt="img" />
    
  </figure>

</p>
<p>C#中的this，是一个特殊的对象引用，它代表对象自身。</p>
<p>This = me</p>
<p>位于同一类内部的成员彼此访问，本质上是通过this这一特殊引用来完成的。只不过这个关键字通常被省略了。</p>
<p><strong>通过对象变量来访问对象的实例成员</strong>，是面向对象编程的一个基本准则。</p>


<h3 class="relative group">装箱与拆箱 
    <div id="%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>C#是一种“<strong>强类型</strong>”的编程语言</p>
<ul>
<li>强类型的编程语言，要求变量“先定义后使用”，并且变量要拥有明确的特定的类型。</li>
<li>特定类型的变量，只能接收特定类型的值</li>
</ul>
<p>如果把值类型数值赋给引用类型变量：</p>
<pre tabindex="0"><code>int num = 123;
object obj = num;
</code></pre><p>会在托管堆中创建一个对象 值是num，然后让obj指向这个对象，这个过程的术语就是装箱</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-30.png" alt="img" />
    
  </figure>

</p>
<p>对象赋值给值类型变量：</p>
<pre tabindex="0"><code>int num = 123;
object obj = num;
int value = (int)obj;
</code></pre><p>把对象里面所包容的数值取出来、然后再把它赋值给一个值类型的变量。这个过程就是拆箱</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-31.png" alt="img" />
    
  </figure>

</p>
<p>这种装箱/拆箱的特性是面向对象特有的，使用的并不多，会对程序的性能造成影响</p>


<h3 class="relative group">方法参数传送方式与ref 
    <div id="%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%81%E6%96%B9%E5%BC%8F%E4%B8%8Eref" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%81%E6%96%B9%E5%BC%8F%E4%B8%8Eref" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>两种类型的方法参数</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-32.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-33-1024x538.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-34.png" alt="img" />
    
  </figure>

</p>
<p>就是一个是复制值过去，一个是传地址过去，跟指针一样</p>
<p><strong>按“引用方式”传递值类型参数</strong></p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-35.png" alt="img" />
    
  </figure>

</p>
<p>返回ref的函数</p>
<p>不仅可以将方法的参数定义为ref的，甚至连方法的返回值，也可以是ref的！</p>
<p>为此，我们设计一个实例，展示返回ref结果的方法是什么样子的。</p>
<p>编写一个工程师类</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-36.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-37-1024x530.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-38.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-39.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-40-1024x495.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-41-1024x584.png" alt="img" />
    
  </figure>

</p>
<ul>
<li>
<p>使用ref，其实就是给保存值类型数据的那块内存区域（注意它在线程堆栈中），关联上不同的名字。通过这些名字，可以很方便地直接“找到”这块内存区域，并进而读取或修改其内容。</p>
</li>
<li>
<p>因此，ref可以用于在两个方法之间共享相同的值类型数据。</p>
</li>
<li>
<p>默认情况下，当方法参数是值类型时，实参按“值”方式传送，也就是外部数据值被复制了一份传给方法，方法内所访问的数据，其实是外部数据的副本。</p>
</li>
<li>
<p>当方法参数是引用类型时，对象的引用被传给了方法，方法内所访问的对象，与方法外部变量所引用的对象，是同一个。</p>
</li>
<li>
<p>当方法参数是值类型时，可以给其加上ref修饰符，在调用时不复制原数据值，而是将其“引用（即地址）”传给了方法，方法内所访问的数据值，与外部所使用的数据值，是同一个。</p>
</li>
<li>
<p>当方法返回值类型数据时，也可以给其加上ref修饰符，将其地址（而不是将数据值复制一份）传给外界。</p>
</li>
<li>
<p>使用ref的好处，在于数据“呆在一个地方不动”，程序运行时只存在“地址值”（一个64位二进制长度的整数值）的复制，而不需要复制整个数据值（有些值类型，比如struct结构可以包容有许多成员），从而减少了不必要的内存存取操作，有助于程序性能的提升。</p>
</li>
</ul>


<h3 class="relative group">只读的数据类型 
    <div id="%E5%8F%AA%E8%AF%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8F%AA%E8%AF%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>通常情况下，对象的字段值是可以修改的</p>
<pre tabindex="0"><code>class Program
{
    static void Main(string[] args)
    {
        MyClass obj = new MyClass();
        obj.add(1);//Vaule+1
        obj.printVaule();//输出101
    }
}

class MyClass
{
    private int Vaule = 100;
    public void add(int step)
    {
        this.Vaule += step;
    }
    public void printVaule()
    {
        Console.WriteLine(&#34;Vaule = {0}&#34;, Vaule);
    }
}
</code></pre><p>但是在.NET基类库中，我们发现</p>
<p>值类型的DateTime不太一样：</p>
<pre tabindex="0"><code>DateTime Date = new DateTime(2022, 5, 7);
Date.AddDays(1); //增加一天
Console.WriteLine(Date); //输出仍为2022/5/7
</code></pre><p>字符串类型也不太一样：</p>
<pre tabindex="0"><code>string str = &#34;abcd&#34;;
str.ToUpper(); //改为大写
Console.WriteLine(str); //输出仍为abcd
</code></pre><p>DateTime和string类型变量居然都是只读的！一旦创建之后，内容不可改！</p>
<p><strong>为什么要设计“只读”的类？</strong></p>
<ul>
<li>现在的计算机和手机、平板，都是<strong>多核</strong>的。</li>
<li>为发挥多核CPU的计算能力，应用程序应该是“<strong>多线程</strong>”的</li>
<li>在“多线程”环境下，多个线程访问同一个对象时，因为对象是只读的，无需互斥（一次只允许一个访问，一个在访问时，其他等待），就可以保证数据读取不会出错（想一想，如果不是只读的，一个线程正在读，另一个线程正在写，一切就乱套了）。</li>
</ul>
<p>所以，在“多线程”环境下，使用只读对象可以提升程序的性能。</p>
<p><strong>设计“只读”的类</strong></p>
<p>当外界期望修改对象的字段值时，不是修改原有对象的字段值，而是<strong>新建</strong>一个对象，让它的字段值符合要求，然后把这个新对象返回给外界！</p>
<pre tabindex="0"><code>class MyOnlyReadClass
{
    private int Vaule = 100;
    public MyOnlyReadClass add(int step)
    {
        MyOnlyReadClass obj = new MyOnlyReadClass();
        obj.Vaule = this.Vaule;
        obj.Vaule += step;
        return obj;
    }
    public void printValue()
    {
        Console.WriteLine(&#34;Value = {0}&#34;, this.Vaule);
    }
}
</code></pre><p>使用例如下</p>
<pre tabindex="0"><code>//只读类的使用例
MyOnlyReadClass readonlyObj = new MyOnlyReadClass();
MyOnlyReadClass readonlyObj2 = readonlyObj.add(1);
Console.WriteLine(readonlyObj2  readonlyObj); //false
readonlyObj.printValue(); //输出100
readonlyObj2.printValue(); //输出101
</code></pre><p>readonlyObj2 readonlyObj 为false 他们引用不同的对象</p>
<p>C# 7以后，允许定义只读的结构体：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-42.png" alt="img" />
    
  </figure>

</p>
<p>如果编译器发现程序中任何的地方有代码尝试修改只读结构体的字段，就会报告编译错误，从而将“错误消灭在萌芽状态”。</p>
<p>只读的结构体方法</p>
<p>在C# 8中，允许你将结构体中的某个方法定义为只读的，编译器会检查这个方法内部有没有代码修改了外部的数据（比如，修改了结构体中的某个字段的值，或者是调用了另一个“非只读”的方法），如果发现了这种情况，编译器就会引发一个“编译错误”，提醒你修正它。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-43.png" alt="img" />
    
  </figure>

</p>
<p>小结：</p>
<ul>
<li>通常情况下，对象的状态是可以更改的，这在多线程环境下可能会引发难以预料的错误，因此，设计只读的数据结构（包括类和结构体）是推荐的做法。</li>
<li>从C# 7以后，C#引入了readonly这个关键字，从语法层面引导开发者编写“只读”的代码，让编译器来检查现有的代码，用好这些特性，有助于开发者写出Bug更少，更为健壮的代码。</li>
</ul>


<h3 class="relative group">类的静态成员 
    <div id="%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>在实际开发中，我们可能会有一些“到处都要使用”的功能需要实现，比如各种标准的数学函数以及圆周率等数学常量，在C#中如何定义并实现它们？</p>
<p>.NET基类库中Math类所封装的部分数学常量与函数</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-44.png" alt="img" />
    
  </figure>

</p>
<p>使用const定义数学常量</p>
<p>使用static定义数学函数</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-45.png" alt="img" />
    
  </figure>

</p>
<p>使用<strong>static</strong>关键字来定义类的静态成员</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-46-1024x516.png" alt="img" />
    
  </figure>

</p>
<p>两种类型的类成员</p>
<p>**静态（static）**方法/字段/属性：使用static定义</p>
<p>**实例（instance）**方法/字段/属性：不使用static定义</p>
<p><strong>实例的类成员想要访问必须要通过一个对象变量，静态的对象成员不需要对象变量，只需要一个类名就可以</strong></p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-47-1024x501.png" alt="img" />
    
  </figure>

</p>
<p>类的<strong>静态方法</strong>可以访问类的<strong>静态字段</strong>，但是不能直接访问类的<strong>实例字段</strong></p>
<p>相应的，<strong>实例的方法</strong>可以访问<strong>静态字段</strong>，也可以访问<strong>实例字段</strong></p>
<p>另一个实例：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-49.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-48.png" alt="img" />
    
  </figure>

</p>
<p>每次创建都各给两个字段+1，dynamicVar字段为实例成员，staticVar字段为静态成员</p>
<p>输出时 dynamicVar = 1 staticVar = 100</p>
<p>事实上：</p>
<ul>
<li>
<p>创建了100个MyClass对象，每个对象都拥有一个独立的dynamicVar字段</p>
</li>
<li>
<p>创建了100个MyClass对象，共享同一个staticVar字段</p>
</li>
<li>
<p>类的实例成员只能通过对象来访问。每个对象都有一份自己独享的实例成员，是“<strong>个人财产</strong>”。</p>
</li>
<li>
<p>类的静态成员归所有对象所共享，是“<strong>国有资产</strong>”。</p>
</li>
</ul>
<p>类成员的访问规则：</p>
<ul>
<li>类的实例方法可以访问类的实例字段；</li>
<li>类的实例方法可以访问类的静态成员；</li>
<li>类的静态方法只能访问类的静态字段。</li>
</ul>
<p>使用静态成员的好处</p>
<ol>
<li>由于静态成员并不依附于特定的对象，而可以直接调用，因此，它使用更方便。</li>
<li>编写静态方法时，如果它需要访问静态的字段或属性，则要注意在多线程环境下，有不有可能出现数据存取错误的情况。</li>
<li>C#提供有一种非常方便的“扩展方法”，能够在不修改源代码的前提下，动态地给特定的类型添加新的方法，这一特性，就是使用“静态类 + 静态方法”实现的，在后面的课程中会介绍这块的内容。</li>
</ol>


<h3 class="relative group">匿名类型 
    <div id="%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">没有名字的“临时”对象 
    <div id="%E6%B2%A1%E6%9C%89%E5%90%8D%E5%AD%97%E7%9A%84%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%B2%A1%E6%9C%89%E5%90%8D%E5%AD%97%E7%9A%84%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>在C#中，如果你只需要“临时”使用一个对象，并且这个对象只在这个地方使用，那么，你可以使用匿名类型达到这个目的：</p>
<pre tabindex="0"><code>var user = new
{
    Id = 1,
    Name = &#34;傻逼一样的不会你妈闭嘴的舍友&#34;,
    Age = 3
};
Console.WriteLine(&#34;用户的id为&#34;+user.Id+&#34;名称为&#34;+user.Name+&#34;年龄为&#34;+user.Age+&#34;岁&#34;);
</code></pre><p>user对象内的id name age的类型都是编译器推断的</p>
<p>对于匿名类型，C#编译器会将<strong>匿名类型转换</strong>为一个类，在程序运行时，以这个类为模板，创建一个匿名对象供程序使用。</p>
<p>所以所谓的没有类型其实只是针对于在编写代码的时候的没有。</p>


<h4 class="relative group">将匿名对象序列化为Json 
    <div id="%E5%B0%86%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%BAjson" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%B0%86%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%BAjson" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>将一个对象属性信息提取出来，生成一个Json字符串的过程，称为对象的“Json序列化”。
.NET基类库中有相应的组件，可以直接完成这个工作：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-50.png" alt="img" />
    
  </figure>

</p>
<p>注意，默认情况下，属性中的“中文字符”，会被转义，这个是Json规范所约定的。</p>
<p>不转义中文字符串：</p>
<p>如果希望汉字能保持原样，可以设置JsonSerializer不对中文字符进行转义：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-51.png" alt="img" />
    
  </figure>

</p>
<p>示例中用到的JsonSerializer是.NET Core基类库中的内置组件，在.NET Core项目中可以直接拿来就用。
另有一个历史悠久的第三方Json库——Newtonsoft.Json，无需任何设置就能在序列化汉字时保持原样不动，但必须单独使用NuGet管理器在线安装后，项目中才能用它。</p>


<h4 class="relative group">匿名类型的应用场景-1 
    <div id="%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>匿名类型通常只在方法内部使用，主要用于临时表达一些信息，用完就扔……</p>
<p>比如，在ASP.NETCore Web应用中，就经常使用匿名类型封装客户端需要的信息。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-52-1024x479.png" alt="img" />
    
  </figure>

</p>


<h4 class="relative group">匿名类型的应用场景-2 
    <div id="%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2" aria-label="锚点">#</a>
    </span>        
    
</h4>
<ul>
<li>匿名类型的另一个典型应用场景，是用在LINQ查询中，将需要的信息动态地装配为一个匿名对象的信息，返回给调用者。</li>
<li>在后面的课程学习到LINQ查询时，你会看到相应的示例。</li>
</ul>


<h3 class="relative group">多窗体编程初步 
    <div id="%E5%A4%9A%E7%AA%97%E4%BD%93%E7%BC%96%E7%A8%8B%E5%88%9D%E6%AD%A5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%A4%9A%E7%AA%97%E4%BD%93%E7%BC%96%E7%A8%8B%E5%88%9D%E6%AD%A5" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-53-1024x589.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-54-1024x557.png" alt="img" />
    
  </figure>

</p>


<h2 class="relative group">C#中的数组 
    <div id="c%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#c%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">数组 
    <div id="%E6%95%B0%E7%BB%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%95%B0%E7%BB%84" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>我们把一组有顺序的数据所构成的整体，称为“数组”。</p>
<p>数组中数据的位置编号，从0开始依次递数组中数据的位置编号，从0开始依次递</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-55.png" alt="img" />
    
  </figure>

</p>
<p>数组中的单个数据，称为“元素”，它们具有相同的数据类型。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-56-1024x295.png" alt="img" />
    
  </figure>

</p>
<p>数组一旦创建之后，尺寸保持不变，元素在内存中连续分布。</p>
<p>数组是一个对象，数组变量（arr）引用这个数组对象。</p>
<p>通过“数组名[索引值]”访问单个的数组元素。</p>
<pre tabindex="0"><code>//定义一个包容 8 个元素的数组，并直接对其初始化
int[] arr = new int 8 [] { 234, 565, 23, 90, 1, 34, 89, 13};

//按照索引访问数组元素
arr[7]++; //最后一个元素自增 1

//使用 for 循环遍历数组元素
for (int i = 0; i &lt; arr.Length ; i++)
{
    Console.WriteLine(arr [{0}]={1}&#34;, i , arr[i]);
}

//也可以使用 foreach 循环遍历数组元素
foreach (var element in arr)
{
    Console.WriteLine(element);
}
</code></pre><p>数组不允许“越界访问”，否则，会抛出一个IndexOutOfRangeException</p>


<h3 class="relative group">对象数组 
    <div id="%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>数组中的元素可以是引用类型的，这种数组俗称为“对象数组”。</p>
<pre tabindex="0"><code>var stringArr = new string[] { &#34;How&#34;, &#34;are&#34;, &#34;you&#34;, &#34;?&#34; };
</code></pre><p>变量stringArr引用一个包容4个元素的数组对象，每个元素又引用一个字符串对象……</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-57.png" alt="img" />
    
  </figure>

</p>
<p>数组本身是一个引用类型，因此，如果它被传送给一个方法，则方法内部对数组的修改，会直接作用于“原始”的数组对象。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-58-1024x208.png" alt="img" />
    
  </figure>

</p>
<p>但是被修改的并不是之前的字符串How are you本身，而是数组所引用的对象被修改了，之前的字符串仍然存在，等待被垃圾回收器回收</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-59-1024x543.png" alt="img" />
    
  </figure>

</p>
<ul>
<li>除了数组，.NET 基类库中还定义有许多的集合，比如List， HashTable，Dictionary等等，它们虽然有各自的特性和适合的应用场景，但同时又与数组有着许多的共性。</li>
<li>学习与掌握好数组相关的知识与编程技巧，能为你学习与掌握.NET 基类库中其他的集合对象打好基础。</li>
<li>我们将在“LINQ与数据结构”这门课程中，更为系统与深入地学习各种数据集合对象以及相关的数据处理技巧。</li>
</ul>


<h2 class="relative group">继承 
    <div id="%E7%BB%A7%E6%89%BF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BB%A7%E6%89%BF" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">继承概述 
    <div id="%E7%BB%A7%E6%89%BF%E6%A6%82%E8%BF%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BB%A7%E6%89%BF%E6%A6%82%E8%BF%B0" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>继承是对现实生活中的“分类”概念的一种模拟。</p>
<p>示例：狮子是一种动物。</p>
<p>狮子拥有动物的一切基本特性，但同时又拥有自己的独特的特性，这就是“继承”关系的重要性质。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-60.png" alt="img" />
    
  </figure>

</p>
<p>形成继承关系的两个类之间，是“<strong>IS_A</strong>”关系</p>
<p>IS_A译为：&ldquo;是一种&rdquo;</p>
<p>在C#中实现继承：</p>
<p>首先定义一个Animal类：</p>
<pre tabindex="0"><code>class Animal
{
}
</code></pre><p>Animal类被称为父类（parent class） 或者 基类（base class）</p>
<p>然后定义一个类Lion</p>
<pre tabindex="0"><code>class Lion : Animal
{
}
</code></pre><p>Lion类被称为类（child class）</p>
<p>从外部使用者角度看来，子类“自动”拥有了父类声明为<strong>public</strong> 和 <strong>protected(保护)</strong> 的成员，这就是继承的最重要特性之一。</p>
<p>父类：</p>
<pre tabindex="0"><code>public int Pi = 100;
public void Pf()
{
    Console.WriteLine(&#34;Parent.Pf&#34;);
}
protected int Pj = 200;
protected void Pg()
{
    Console.WriteLine(&#34;Parent.Pg()&#34;);
}
private int k = 300;
</code></pre><p>子类：</p>
<pre tabindex="0"><code>class Child : Parent
{
    public void cf()
    {
        Pg(); //子类可以直接访问父类的保护成员
        Pj += 200;
        Console.WriteLine(&#34;Child.cf()&#34;);
        Console.WriteLine(&#34;Parent.Pj = {0}&#34;, Pj);
    }
}
</code></pre><p>子类中的代码可以直接访问父类保护级别的成员，但外界不能通过对象变量来直接访问声明为保护级别的类成员。</p>
<p>应用：</p>
<pre tabindex="0"><code>class Program
{
    static void Main(string[] args)
    {
        Child c = new Child();
        //可以通过子类变量访问定义在基类的公有成员
        c.Pi = 300;
        Console.WriteLine(&#34;Parent.Pi = {0}&#34;, c.Pi);
        c.Pf();
        //c.Pj = 1000; Error!,不能访问保护级别的成员
        c.cf(); //可以通过子类定义的公有方法访问基类保护级别的成员
    }
}
</code></pre><p>更进一步：继承环境下的字段访问规则</p>
<ul>
<li>同一类中的实例方法可以访问所有字段。</li>
<li>子类实例方法可以访问父类中的protected和public的字段，但不能访问private的字段。</li>
<li>变量同名时，“离得最近”、“关系最密切” 的变量起作用。</li>
</ul>


<h3 class="relative group">方法的重载与覆盖 
    <div id="%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E4%B8%8E%E8%A6%86%E7%9B%96" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E4%B8%8E%E8%A6%86%E7%9B%96" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-61.png" alt="img" />
    
  </figure>

</p>
<pre tabindex="0"><code>Animal an = null;
Lion lion = new Lion();
an = lion; //正确
lion = an; //编译时错误，父类无法给子类赋值
lion = (Lion)an; //当我们确定an是一个Lion，可以强制类型转换
Monkey m = (Monkey)an; //虽然可以通过编译，因为an是一个Lion，所以会在运行时报错错误。
</code></pre><p><strong>子类对象可以赋值给父类（基类）变量</strong>，这实际上是“<strong>IS_A</strong>”关系的体现。</p>
<p><strong>当子类、父类的方法名相同时，有两种情况：</strong></p>
<p><strong>Overload（重载）</strong></p>
<pre tabindex="0"><code>class Parent{
    public void OverLoadF() { 
    }
}
class Child : Parent{
    public void OverloadF(int i){
    }
}
</code></pre><p><strong>Override（重写/覆盖）</strong></p>
<pre tabindex="0"><code>class Parent{
    public virtual void OverRideF() { 
    }
}
class Child : Parent{
    public override void OverRideF(){
    }
}
</code></pre><p>当方法的元素不同时，会出现<strong>Overload（重载）</strong>，相同时则会进行<strong>Override（重写/覆盖）</strong></p>
<p>子类父类方法字段“<strong>一模一样</strong>”时</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-62.png" alt="img" />
    
  </figure>

</p>
<p>测试代码：</p>
<pre tabindex="0"><code>Parent p = new Parent();
Child c = new Child();

p.HideF();
c.HideF();

p = c; //基类变量引用子类对象
p.HideF(); //输出的还是父类的结果
(p as Child).HideF(); //只有转成子类类型才会运行子类方法

Console.WriteLine(p.Value); //父类
Console.WriteLine((p as Child).Value); //子类字段

Console.ReadKey();
</code></pre><p>开发建议：不要自找麻烦！</p>
<p>在实际开发时，不要在子类中定义与父类一模一样的成员（包括字段、属性和方法）！</p>


<h3 class="relative group">提升软件开发效率的法宝——重用 
    <div id="%E6%8F%90%E5%8D%87%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%B3%95%E5%AE%9D%E9%87%8D%E7%94%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%8F%90%E5%8D%87%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%B3%95%E5%AE%9D%E9%87%8D%E7%94%A8" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>在面向对象思想发展的初期，通过继承复用代码曾经被认为是面向对象最重要的目标之一。</p>
<p>很遗憾，实践中人们发现在开发中滥用继承后患无穷……</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-63.png" alt="img" />
    
  </figure>

</p>
<p>代码间强耦合，拥有极深的类型继承树，上层基类一改，所有子类均受影响，并且这种变动所带来的影响很难预计……</p>
<ul>
<li>不要仅仅为了“代码重用”而引入很深层次的继承，想想能不能通过“对象组合”（后面课程介绍）的方式实现相同的目的。</li>
<li>当且仅当两个类之间是非常明确的“IS_A”关系，并且程序中希望利用面向对象的“继承多态”特性（后面课程介绍）时，才引入“继承”。</li>
</ul>
<p>继承是现实世界对事物“类别”关系的一种模拟，在了解了与继承之间的相关知识之后，请观察一下你周围的事物，它们中的哪些可以应用“继承” 构建出一个面向对象的软件模型？</p>


<h2 class="relative group">抽象类与接口 
    <div id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">抽象类与抽象方法 
    <div id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>在一个类前面加上“<strong>abstract</strong>”关键字，此类就成为了抽象类。</p>
<p>一个方法前面加上“<strong>abstract</strong>”关键字，此方法就成为了抽象方法。</p>
<pre tabindex="0"><code>abstract class Fruit   //抽象类
{
    public abstract void GrowInArea(); //抽象方法
}
</code></pre><ul>
<li>抽象方法<strong>不包容</strong>任何<strong>实现</strong>代码。</li>
<li>无法使用new关键字直接创建抽象类的对象。</li>
<li>包含抽象方法的类一定是抽象类，但抽象类中的方法不一定是抽象方法，抽象类中可以包容“普通的”方法。</li>
</ul>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-64-1024x562.png" alt="img" />
    
  </figure>

</p>
<p>“抽象类”怎么用？</p>
<p>不能创建抽象基类的对象，只能用它来引用子类的对象。</p>
<pre tabindex="0"><code>抽象类名 变量名 = new 继承自此抽象类的具体子类名();
</code></pre><p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-65-1024x341.png" alt="img" />
    
  </figure>

</p>
<p>让我们先从“继承”聊起……</p>
<p>“继承”是对现实世界中“<strong>是一种（IS_A）</strong>”关系的模拟。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-66.png" alt="img" />
    
  </figure>

</p>
<p>现在试着为以下一个场景建立一个面向对象的编程模型</p>
<p>鸭子是一种鸟，会游泳，同时又是一种食物。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-67.png" alt="img" />
    
  </figure>

</p>
<p>• “会游泳”这个方法放在哪个类中？</p>
<ol>
<li>并不是只有鸭子一种鸟会游泳。</li>
<li>并不是所有鸟都会游泳。</li>
</ol>
<p>因此不知道“会游泳”这个特性应该放到哪个类中</p>
<p>C#/Java等编程语言不支持多继承</p>
<p>解决方案就是使用接口：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-68-1024x471.png" alt="img" />
    
  </figure>

</p>


<h3 class="relative group">接口 
    <div id="%E6%8E%A5%E5%8F%A3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%8E%A5%E5%8F%A3" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>C#中接口的特点</p>
<p>使用interface关键字定义接口 <em>接口的名字通常以“I”打头</em>。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-69.png" alt="img" />
    
  </figure>

</p>
<p>接口中的方法只有声明，不包容任何代码</p>
<p>经典的面向对象编程语言，最初接口中除了函数或属性/字段定义，是没有其他语言成份的，但近些年来，这条规则被突破，Java、C#纷纷允许在接口中放入有实现代码的方法，后面课程介绍相关的内容。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-70-1024x492.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-71-1024x592.png" alt="img" />
    
  </figure>

</p>
<p>“接口”小结</p>
<ul>
<li>与抽象基类相比，接口不包含任何的实现代码接口可以看成是一种“纯”的抽象类。</li>
<li>接口实际上可以看成一种约定，对于所有实现了接口的类，可以说“它们看上去都是这样的……”，但到底类类，可以说“它们看上去都是这样的……”，但到底类是如何“遵守”与实现这种规定，完全由类自己来定。</li>
<li>接口在面向对象开发实践中用得极广。</li>
</ul>


<h2 class="relative group">理解“多态” 
    <div id="%E7%90%86%E8%A7%A3%E5%A4%9A%E6%80%81" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%90%86%E8%A7%A3%E5%A4%9A%E6%80%81" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">继承多态 
    <div id="%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>“多态性”一词最早用于生物学，指同一种族的生物体虽然具有相同的本质特征，但在不同环境中可能呈现出不同的特性。如东北大米对比泰国香米、各种种类的狗之间对比。</p>
<p>面向对象开发中的多态</p>
<p>在面向对象理论中，多态是：</p>
<p>同一操作施加于不同的类的实例，不同的类将进行不同的解释，最后产生不同的结果。</p>
<p>从编程角度来看，“多态”表现为：</p>
<p>同样的程序语句，在不同的上下文环境中可能得到不同的运行结果。</p>
<p>多态实例：</p>
<p>苹果和菠萝都是一种水果，它们都有“适宜种植区域” 这个信息值得关注。</p>
<p>因此为苹果、菠萝建立面向对象软件模型</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-72-1024x408.png" alt="img" />
    
  </figure>

</p>
<p>水果被定义为“抽象类”，其中定义一个抽象方法GrowInArea()，表示“种植区域”，要求子类必须重写。</p>
<p>苹果和菠萝成为Fruit的子类，分别为其抽象方法GrowInArea()提供了不同的实现代码，这种多态编程方式称为 “<strong>子类重写基类的抽象方法</strong>”。是一种最常见的多态代码的表现形式。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-73-1024x352.png" alt="img" />
    
  </figure>

</p>
<p>相同的一句“f.GrowInArea()”，由于 <strong>f</strong> 引用的对象不同，导致其输出结果不同。</p>
<p>这点就是多态特性的一种体现</p>
<p>“真正的”多态代码：</p>
<pre tabindex="0"><code>static void ShowFruitGrowInAreaInfo(Fruit fruit)
{
    fruit.GrowInArea();
}
</code></pre><p>此方法中的代码只调用“基类” 中定义的方法，不涉及任何具体的子类，因此，此方法里面全部都是“多态” 代码。</p>
<p>多态代码调用实例</p>
<pre tabindex="0"><code> //中国哪儿适宜种苹果？
ShowFruitGrowInAreaInfo(new Apple());
//中国哪儿适宜种菠萝？
ShowFruitGrowInAreaInfo(new Pineapple());
</code></pre><p>ShowFruitGrowInAreaInfo()方法可以输出任何一种水果（比如桔子）的“适宜种植地”信息，只要程序中有相应的派生自Fruit类的特定水果类（比如Orange）即可。</p>
<p>需要扩充的时候，只需要定义一个比如是Orange，然后继承自Fruit即可</p>
<p>多态的代码，只调用“基类”中定义的方法，存取 “基类”中定义的字段和属性，简单地说，就是：</p>
<p><strong>针对“基类”编程</strong></p>


<h3 class="relative group">动物园示例 
    <div id="%E5%8A%A8%E7%89%A9%E5%9B%AD%E7%A4%BA%E4%BE%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8A%A8%E7%89%A9%E5%9B%AD%E7%A4%BA%E4%BE%8B" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>假设某动物园管理员每天需要给他所负责饲养的狮子、猴子和鸽子喂食。我们用一个程序来模拟他喂食的过程。</p>


<h4 class="relative group">面向对象建模中的“名词法” 
    <div id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1%E4%B8%AD%E7%9A%84%E5%90%8D%E8%AF%8D%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1%E4%B8%AD%E7%9A%84%E5%90%8D%E8%AF%8D%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p><em>用人类的自然语言描述出软件要干的事，挑出其中的名词，它们就是“候选”的“类”。</em></p>
<p>描述：</p>
<p>动物园管理员每天需要给他所负责饲养的狮子、猴子和鸽子喂食。</p>
<p>抽取名词：</p>
<p>管理员、鸽子、狮子、猴子、动物园</p>
<p>上面去掉过于宽泛的动物园名词。</p>


<h4 class="relative group">使用“名词法”建立软件模型 
    <div id="%E4%BD%BF%E7%94%A8%E5%90%8D%E8%AF%8D%E6%B3%95%E5%BB%BA%E7%AB%8B%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BD%BF%E7%94%A8%E5%90%8D%E8%AF%8D%E6%B3%95%E5%BB%BA%E7%AB%8B%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9E%8B" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>三种动物对应三个类，每个类定义一个eat()方法，表示吃饲养员给它们的食物。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-75.png" alt="img" />
    
  </figure>

</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-76.png" alt="img" />
    
  </figure>

</p>
<p>再设计一个Feeder类代表饲养员，其name字段保存饲养员名字，三个方法分别代表喂养三种不同的动物，其参数分别引用三种动物对象。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-77.png" alt="img" />
    
  </figure>

</p>
<p>喂食过程：</p>
<pre tabindex="0"><code>static void Main(string[] args)
{
    Monkey m = new Monkey();
    Pigeon p = new Pigeon();
    Lion l = new Lion();

    Feeder f = new Feeder();
    f.Name = &#34;小李&#34;;

    f.FeedMonkey(m);
    f.FeedPigeon(p);
    f.FeedLion(l);
}
</code></pre><p>但是不同的饲养员，应该喂食的动物是不固定的。或者可能饲养员每个月饲养的动物也不相同。</p>
<p>因此这样设计Feed是不合理的</p>


<h4 class="relative group">重构：引入继承 
    <div id="%E9%87%8D%E6%9E%84%E5%BC%95%E5%85%A5%E7%BB%A7%E6%89%BF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%87%8D%E6%9E%84%E5%BC%95%E5%85%A5%E7%BB%A7%E6%89%BF" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-78.png" alt="img" />
    
  </figure>

</p>
<p>设计抽象类Animal，定义抽象方法eat()，每个子类都覆写这个eat</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-79.png" alt="img" />
    
  </figure>

</p>
<p>重新设计Feeder类的喂养方法</p>
<p>因此喂食过程变成了：</p>
<pre tabindex="0"><code>static void Main(string[] args)
{
    Monkey m = new Monkey();
    Pigeon p = new Pigeon();
    Lion l = new Lion();

    Feeder f = new Feeder();
    f.Name = &#34;小李&#34;;

    f.FeedAnimal(m);
    f.FeedAnimal(p);
    f.FeedAnimal(l);
}
</code></pre><p>事实上还可以进一步优化</p>
<p>然后我就听不懂了</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-80-1024x529.png" alt="img" />
    
  </figure>

</p>


<h3 class="relative group">“多态”的好处 
    <div id="%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>从这个示例中可以看到，通过在编程中应用多态：</p>
<p>可以使我们的代码具有<strong>更强的适用性</strong>。</p>
<p>当需求变化时，多态特性可以帮助我们将<strong>需要改动的地方减少到最低限度</strong>。</p>


<h3 class="relative group">“多态”具体实现方式有两种： 
    <div id="%E5%A4%9A%E6%80%81%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E4%B8%A4%E7%A7%8D" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%A4%9A%E6%80%81%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E4%B8%A4%E7%A7%8D" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-81.png" alt="img" />
    
  </figure>

</p>


<h2 class="relative group">C#接口新特性 
    <div id="c%E6%8E%A5%E5%8F%A3%E6%96%B0%E7%89%B9%E6%80%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#c%E6%8E%A5%E5%8F%A3%E6%96%B0%E7%89%B9%E6%80%A7" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">接口中的静态成员 
    <div id="%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>在C# 8中，可以为接口添加静态的字段与静态的方法。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-82.png" alt="img" />
    
  </figure>

</p>
<p>接口中的静态字段多为只读类型的字段，代表与本接口所代表的事物密切相关的数据。</p>
<p>而静态方法多用于封装一些与本接口所代表的事物密切相关的“公用”代码。</p>
<p>接口中的静态成员，需要通过接口名来访问：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-84.png" alt="img" />
    
  </figure>

</p>
<p>通过接口名，可以非常清晰地分辨出——“<strong>此信息归属于拥有哪种特性的事物，此功能是由拥有哪种特性的事物所提供的</strong>”。</p>


<h3 class="relative group">实现接口的类 
    <div id="%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>实现接口的具体类型，可以使用本接口所定义的静态字段：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-85.png" alt="img" />
    
  </figure>

</p>
<p>放在接口中的静态成员，通常封装了相关的信息和代码，它们与接口所抽象出来的“事物特性”密切相关。</p>
<p>实现了接口的对象，它本身就有接口所定义的这些特性，因此，它使用接口中的静态成员就非常自然，这种编程方式，体现出了“<strong>将相关的东西（或代码）集中放置以便于管理和维护</strong>”这样一种推荐的做事方法。</p>


<h3 class="relative group">接口默认方法 
    <div id="%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>我们也可以在接口中定义一个“普通的”方法：</p>
<pre tabindex="0"><code>interface MyInterfaceWithDefaultMethods
{
    void PringTypeInfo()
    {
        //在此方法中可以使用this引用那些实现了本接口的对象
        Console.WriteLine($&#34;本对象的类型为{this.GetType()}&#34;);
    }
}
</code></pre><pre tabindex="0"><code>class Myclass : MyInterfaceWithDefaultMethods
{

}

class MyOtherCalss : MyInterfaceWithDefaultMethods
{
    public void PrintTypeInfo()
    {
        Console.WriteLine(&#34;我可以提供我自己的实现方案&#34;);
    }
}
</code></pre><p>实现接口的类，如果不提供此方法的自己的实现代码，那就使用接口所定义的，这就是接口所定义的方法为什么被称为“<strong>默认方法</strong>”的原因。</p>
<p>MyClass和MyOtherClass在定义好之后，使用起来和其他类是没有区别的。</p>


<h2 class="relative group">模式匹配 
    <div id="%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D" aria-label="锚点">#</a>
    </span>        
    
</h2>
<ul>
<li>所谓“<strong>模式（pattern）</strong>”，其实就是一个“判断标准”，你可以用它来判断某些事物是否符合这个标准，当符合时，称为“<strong>匹配（Match）</strong>”。</li>
<li>在软件开发中，模式通常使用一个返回bool值的表达式来表达，将特定的数据（比如对象）传给它进行判断，然后依据判断的结果（即是否匹配），决定下一步的工作。</li>
<li>模式匹配代码，可以看成是“增强型”的if/switch语句结构。</li>
<li>大多数模式匹配特性是C# 7.0开始加入的，然后C# 8.0及以后版本继续增强这一特性。</li>
</ul>


<h3 class="relative group">基本语法： 
    <div id="%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">常量匹配模式（constant pattern） 
    <div id="%E5%B8%B8%E9%87%8F%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8Fconstant-pattern" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%B8%B8%E9%87%8F%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8Fconstant-pattern" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>所谓“常量匹配”，就是把一个变量直接与一个具体的数值或对象比较。</p>
<pre tabindex="0"><code>static void ConstantMatch(object input)
{
    if (input is &#34;Hello&#34;)
        Console.WriteLine(&#34;int是一个字符串，其值为Hello&#34;);
    else if (input is 5L)
        Console.WriteLine(&#34;input是一个长整型数值，其值为5&#34;);
    else if (input is 10)
        Console.WriteLine(&#34;input是一个整型数值，其值为10&#34;);
    else
        Console.WriteLine(&#34;input不满足上述的所有条件&#34;);
}
</code></pre><p>比如</p>
<pre tabindex="0"><code>if(input is 10)
.....
</code></pre><p>就等价于</p>
<pre tabindex="0"><code>if(input is int &amp;&amp; (int)input  3)
.....
</code></pre>

<h4 class="relative group">类型匹配模式（Type Pattern） 
    <div id="%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8Ftype-pattern" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8Ftype-pattern" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>所谓“类型匹配”，就是判断一个对象（或数值），是否是某个类型的实例。</p>
<pre tabindex="0"><code>static void TypeMatch(object input)
{
    if (input is string str)
        Console.WriteLine($&#34;int是一个字符串,其值为{str}&#34;);
    else if (input is long longValue)
        Console.WriteLine($&#34;input是一个长整型数值,其值为{longValue}&#34;);
    else if (input is int intValue)
        Console.WriteLine($&#34;input是一个整型数值,,其值为{intValue}&#34;);
    else
        Console.WriteLine($&#34;input不满足上述的所有条件,其类型为{input.GetType()}&#34;);
}
</code></pre><p>在“类型匹配”表达式的后部，可以追加定义一个局部变量，此变量具有本分支所对应的类型，可以用于此分支后继的表达式或语句中。</p>


<h4 class="relative group">使用类型匹配构建复杂的逻辑表达式 
    <div id="%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>类型匹配，可用于构建复杂的逻辑表达式：</p>
<pre tabindex="0"><code>if (input is int x &amp;&amp; x &gt;100)
{
    cw($&#34;Input :{x}&#34;);
}
</code></pre><p>上述模式匹配表达式所引入的变量x，可以用于构建更复杂的表达式，或者直接用于分支所包容的语句中，省去了进行类型转换的麻烦。</p>


<h4 class="relative group">类型匹配表达式，也可以用于switch语句 
    <div id="%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8Eswitch%E8%AF%AD%E5%8F%A5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8Eswitch%E8%AF%AD%E5%8F%A5" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>static void TellMeTheType(object o)
{
    switch (o)
    {
        case string s:
            Console.WriteLine($&#34;o是一个字符串,其值为{s},包含{s.Length}个字符&#34;);
            break;
        case int i:
            Console.WriteLine($&#34;o是一个整数,其值为{i}，其平方数为{i * i}&#34;);
            break;
        default:
            Console.WriteLine($&#34;o的类型为{o.GetType()}&#34;);
            break;
    }
}
</code></pre><p>if和switch语句，是使用模式匹配表达式的主要应用场景。</p>


<h4 class="relative group">属性匹配模式（property pattern） 
    <div id="%E5%B1%9E%E6%80%A7%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8Fproperty-pattern" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%B1%9E%E6%80%A7%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8Fproperty-pattern" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>static void PropertyPattern()
{
    object input = &#34;Hello!&#34;;
    //对象属性匹配测试，后面可以引入，也可以不引入一个的新变量
    if (input is string { Length: 5 } str)
    {
        Console.WriteLine($&#34;str是一个字符串，其长度为5，转为大写之后{str.ToUpper()}&#34;);
    }
    else
    {
        Console.WriteLine($&#34;input不是一个长度为5的字符串&#34;);
    }
}
</code></pre><p>在表达式中的“{”和“}”内部，可以放入多个对象定义的属性，当前版本只支持“判等”运算。</p>
<pre tabindex="0"><code>static void PropertyPattern2()
{
    object testObj = new MyClass()
    {
        Value = 100,
        Info = &#34;Hello&#34;
    };
    //可以判断多个属性的值
    if (testObj is MyClass { Value: 100, Info: &#34;Hello&#34; } myClassObj)
    {
        Console.WriteLine($&#34;str是一个MyClass的实例，其属性值为：{myClassObj.Value}:{myClassObj.Info}&#34;);
    }
    //可以使用逻辑连接符定义复杂的条件，前面所定义myClassObj2变量，可以用在后面的逻辑表达式中
    if (testObj is MyClass { Value: 100 } myClassObj2 &amp;&amp; myClassObj2.Info.Contains(&#34;o&#34;))
    {
        Console.WriteLine($&#34;str是一个MyClass的实例，Info属性值包容字符&#39;o&#39;&#34;);
    }

}
</code></pre>

<h4 class="relative group">When子句 
    <div id="when%E5%AD%90%E5%8F%A5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#when%E5%AD%90%E5%8F%A5" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>static void WhenClause()
{
    object testObj = new MyClass()
    {
        Value = 100,
        Info = &#34;Hello&#34;
    };
    switch (testObj)
    {
        case MyClass obj when obj.Value &lt; 0:
            Console.WriteLine(&#34;MyClass实例，其Value&lt;0&#34;);
            break;
        case MyClass obj when obj.Value &gt;= 100:
            Console.WriteLine($&#34;MyClass实例，其Value={obj.Value}&#34;);
            break;
        //使用“discard”表示不引入额外的变量
        case MyClass _:
            Console.WriteLine(&#34;MyClass实例&#34;);
            break;
        default:
            Console.WriteLine(&#34;testobj不是一个MyClass实例&#34;);
            break;
    }

}
</code></pre><p>在模式匹配表达式中，可以添加一个when子句，对本分支的 “判断规则”进行进一步的 “补充”。</p>
<p>when子句主要用于switch结构，</p>
<p>注意分支的排列顺序。如果不小心，有些分支可能永远执行不到。</p>


<h4 class="relative group">Switch表达式（C# 8） 
    <div id="switch%E8%A1%A8%E8%BE%BE%E5%BC%8Fc-8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#switch%E8%A1%A8%E8%BE%BE%E5%BC%8Fc-8" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>可以将整个switch结构转换为一个表达式，并将其结果传给一个变量：</p>
<pre tabindex="0"><code>//使用switch表达式分情况计算字符串的长度
static int getStringLength(string str)
{
    var result = str switch
    {
        null =&gt; -1,
        &#34;&#34; =&gt; 0,
        _ =&gt; str.Length
    };
    return result;
}
</code></pre><p>注意：
switch表达式的分支，必须覆盖所有的可能性，不能有遗漏，否则，当出现“未能匹配任何分支”时，就会引发错误。</p>
<p>另外要注意一下最后一个分支中使用了“_”，这个符号被称为“discard”，它可以匹配所有情况，并且不会引入任何的变量，通常会把它作为switch表达式的最后一个分支，以保证分支覆盖的完备性。</p>


<h3 class="relative group">模式匹配应用实例 
    <div id="%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">经典的“考试成绩分组”问题 
    <div id="%E7%BB%8F%E5%85%B8%E7%9A%84%E8%80%83%E8%AF%95%E6%88%90%E7%BB%A9%E5%88%86%E7%BB%84%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BB%8F%E5%85%B8%E7%9A%84%E8%80%83%E8%AF%95%E6%88%90%E7%BB%A9%E5%88%86%E7%BB%84%E9%97%AE%E9%A2%98" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>//使用多层嵌套的if语句判断成绩
public static void DoYouPassedUseIf(int score)
{
    if (score &gt; 0 &amp;&amp; score &lt; 60)
        Console.WriteLine($&#34;{score},不及格&#34;);
    else if (score &gt;= 60 &amp;&amp; score &lt; 70)
        Console.WriteLine($&#34;{score},及格&#34;);
    else if (score &gt;= 70 &amp;&amp; score &lt; 80)
        Console.WriteLine($&#34;{score},中&#34;);
    else if (score &gt;= 80 &amp;&amp; score &lt; 90)
        Console.WriteLine(&#34;良&#34;);
    else if (score &gt;= 90 &amp;&amp; score &lt;= 100)
        Console.WriteLine($&#34;{score},优&#34;);
    else
        Console.WriteLine($&#34;{score},无效的成绩&#34;);
}
</code></pre><p>使用传统的多层嵌套条件语句实现，这种方式最大的问题是代码“僵硬”“丑陋”，维护困难。</p>


<h4 class="relative group">改良：使用switch 
    <div id="%E6%94%B9%E8%89%AF%E4%BD%BF%E7%94%A8switch" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%94%B9%E8%89%AF%E4%BD%BF%E7%94%A8switch" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>//使用经典的switch语句判断成绩
public static void DoYouPassedUseSwitch(int score)
{
    //获取其十位上的数
    int scoreDividedBy10 = score / 10;

    switch (scoreDividedBy10)
    {
        case 0: case 1:case 2: case 3: case 4:
        case 5:
            Console.WriteLine($&#34;{score},不及格&#34;);
            break;
        case 6:
            Console.WriteLine($&#34;{score},及格&#34;);
            break;
        case 7:
            Console.WriteLine($&#34;{score},中&#34;);
            break;
        case 8:
            Console.WriteLine($&#34;{score},良&#34;);
            break;
        case 9:
        case 10:
            Console.WriteLine($&#34;{score},优&#34;);
            break;
        default:
            Console.WriteLine($&#34;{score},无效的成绩&#34;);
            break;
    }

}
</code></pre><p>对于需要嵌套多重if语句解决的问题，通常情况下推荐换用switch语句，会让代码变简洁。</p>
<p>但在C#早期版本的switch语句中，仅支持字符串和int等少数类型数值作为分支判断条件，限制很大，比如在本例中，你不得不先对成绩先整除，处理一下才能用于switch语句中。</p>


<h4 class="relative group">改良：switch与模式匹配 
    <div id="%E6%94%B9%E8%89%AFswitch%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%94%B9%E8%89%AFswitch%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>//使用C#模式匹配特性，添加when子句，编写代码判断成绩
public static void DoYouPassedUsePatternMatch(int score)
{
    switch (score)
    {
        //引入一个临时变量s，以便进行模式匹配
        case int s when s &gt; 0 &amp;&amp; s &lt; 60:
            Console.WriteLine($&#34;{s},不及格&#34;);
            break;
        case int s when s &gt;= 60 &amp;&amp; s &lt; 70:
            Console.WriteLine($&#34;{s},及格&#34;);
            break;
        case int s when s &gt;= 70 &amp;&amp; s &lt; 80:
            Console.WriteLine($&#34;{s},中&#34;);
            break;
        case int s when s &gt;= 80 &amp;&amp; s &lt; 90:
            Console.WriteLine($&#34;{s},良&#34;);
            break;
        case int s when s &gt;= 90 &amp;&amp; s &lt;= 100:
            Console.WriteLine($&#34;{s},优&#34;);
            break;
        default:
            Console.WriteLine($&#34;{score},无效的成绩&#34;);
            break;
    }
}
</code></pre><p>C# 7.0以后版本，为switch语句添加了模式匹配特性，通过给每条分支引入一个“临时” 变量，再使用这一变量编写逻辑表达式，让代码变得更为简洁易读。</p>


<h4 class="relative group">改良：使用C#8的特性 
    <div id="%E6%94%B9%E8%89%AF%E4%BD%BF%E7%94%A8c8%E7%9A%84%E7%89%B9%E6%80%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%94%B9%E8%89%AF%E4%BD%BF%E7%94%A8c8%E7%9A%84%E7%89%B9%E6%80%A7" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>//使用switch表达式，配合模式匹配判断成绩
public static void DoYouPassedUseSwitchExpression(int score)
{
    //以下switch表达式的结果，是一个字符串
    string result = score switch
    {
        int s when (s &gt; 0 &amp;&amp; s &lt; 60) =&gt; $&#34;{s},不及格&#34;,
        int s when s &gt;= 60 &amp;&amp; s &lt; 70 =&gt; $&#34;{s},及格&#34;,
        int s when s &gt;= 70 &amp;&amp; s &lt; 80 =&gt; $&#34;{s},中&#34;,
        int s when s &gt;= 80 &amp;&amp; s &lt; 90 =&gt; $&#34;{s},良&#34;,
        int s when s &gt;= 90 &amp;&amp; s &lt;= 100 =&gt; $&#34;{s},优&#34;,
        int _ =&gt; $&#34;{score},无效的成绩&#34;
    };
    Console.WriteLine(result);
}
</code></pre><p>使用C# 8所引入的switch表达式特性，可以进一步地将代码进行精简，连“break;” 现在都可以省掉不写了。</p>


<h4 class="relative group">“模式匹配”在多态场景下很好用！ 
    <div id="%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%9C%A8%E5%A4%9A%E6%80%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%88%E5%A5%BD%E7%94%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%9C%A8%E5%A4%9A%E6%80%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%88%E5%A5%BD%E7%94%A8" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-86.png" alt="img" />
    
  </figure>

</p>
<pre tabindex="0"><code>//使用传统的条件语句计算几何图形的周长
static double GetPerimeter(Shape shape)
{
    if (shape  null)
        throw new ArgumentNullException(nameof(shape));
    Rectangle rect = shape as Rectangle;
    if (rect != null)
        return 2 * (rect.Height + rect.Width);
    Circle circle = shape as Circle;
    if (circle != null)
        return 2 * Math.PI * circle.Radius;
    Triangle triangle = shape as Triangle;
    if (triangle != null)
        return triangle.SideA + triangle.SideB + triangle.SideC;
    throw new ArgumentException(
    $&#34;图形{shape.GetType()} 周长是未知的&#34;, nameof(shape));
}
</code></pre><p>不同类型的几何图形，有不同的周长计算公式，最简单的多态代码，就是先使用类型转换，再按照特定图形的类型选用不同的数学公式，计算其周长。</p>
<p>利用类型匹配，可以写出更清晰易读的代码</p>
<pre tabindex="0"><code>//使用类型匹配来计算几何图形的周长
static double GetPerimeterUseTypePattern(Shape shape)
{
    switch (shape)
    {
        case null:
            throw new ArgumentNullException(nameof(shape));
        case Rectangle rect:
            return 2 * (rect.Height + rect.Width);
        case Circle circle:
            return 2 * Math.PI * circle.Radius;
        case Triangle tri:
            return tri.SideA + tri.SideB + tri.SideC;
        default:
            throw new ArgumentException(
                $&#34;图形{shape.GetType()} 周长是未知的&#34;, nameof(shape));
    }
}
</code></pre><p>直接判断类型并立即引入一个此类型的局部变量用于此分支，让代码简洁。</p>
<pre tabindex="0"><code>//集成When表达式的Switch语句
private static void ShowAreaUsingPatternMatch(IShape shape)
{
    switch (shape)
    {
        case Triangle t when t.Area &lt; 10.0:
            Console.WriteLine($&#34;小三角形面积： {t.Area}&#34;);
            break;

        case Triangle t when t.Area &lt; 50.0:
            Console.WriteLine($&#34;中三角形面积： {t.Area}&#34;);
            break;

        case Triangle t:
            Console.WriteLine($&#34;大三角形面积： {t.Area}&#34;);
            break;

        case Rectangle r:
            Console.WriteLine($&#34;矩形面积 {r.Area}&#34;);
            break;

        default:
            Console.WriteLine(&#34;未知的几何类型&#34;);
            break;
    }
}
</code></pre><p>通过使用when表达式，switch表达式现在具备很强的判断与处理能力，左侧展示了同时依据图形类型和大小进行分类处理几何图形面积的示例代码。</p>
<p>注意：计算面积的具体实现代码，直接集成到了各个图形的Area()方法中，在这个方法里面使用特定的数学公式计算自己的面积。</p>


<h4 class="relative group">小结：模式匹配的应用场景 
    <div id="%E5%B0%8F%E7%BB%93%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%B0%8F%E7%BB%93%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" aria-label="锚点">#</a>
    </span>        
    
</h4>
<ul>
<li>老代码中有使用is或as进行类型判断的地方，则可能是使用模式匹配简化代码的地方。</li>
<li>老代码中包容有多重if/else结构的地方，通常都可以使用引入了模式匹配特性的switch语句或表达式进行简化。</li>
</ul>


<h2 class="relative group">异常处理 
    <div id="%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">什么是异常 
    <div id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8" aria-label="锚点">#</a>
    </span>        
    
</h3>
<ul>
<li>语法错误：在编译时发现，修改代码后可以顺利通过编译。</li>
<li>运行时错误：程序代码能顺利通过编译，但在运行时出现错误（比如用户输入了无效的数据），如果处理不当，程序可能会非法退出。</li>
<li>逻辑错误：程序代码能顺利通过编译，在运行时也没有出现错误，但就是结果不对 ……</li>
</ul>
<p>本讲的异常属于运行时错误</p>
<p>真实的异常:</p>
<pre tabindex="0"><code>static void WhatIsException()
{
    int i = 100, j = 0;
    Console.WriteLine(i / j);
}
</code></pre><p>这种在程序运行时所引发的错误，被称为“<strong>异常（Exception）</strong>”，它表明程序执行期间出现了一个导致程序正常执行流程被中断的特殊问题，期望程序进行的某项操作没有能够完成。</p>
<ul>
<li>当程序运行出现错误时，CLR会创建一个异常对象。在.NET中，异常对象通常是一个Exception类（或其派生的子类）创建的对象。</li>
<li>如果异常出现，而应用程序又没有编写代码处理这一异常， CLR会强行结束整个进程。</li>
</ul>


<h3 class="relative group">异常的捕获与处理 
    <div id="%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%A4%84%E7%90%86" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%A4%84%E7%90%86" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>C#中使用try、catch、finally结构捕获与处理异常</p>
<pre tabindex="0"><code>try
{
    //可能发生运行错误的代码块 ①
}
catch
{
    //用于处理异常的代码块 ②
}
finally
{
    //用于善后 ③
}
</code></pre><p>finally语句块主要用于解决资源泄露的问题，CLR保证他一定会被执行。</p>
<p><em>资源泄露：(资源主要指的是非托管的资源，包括数据库链接的对象、连接的句柄。这些资源是有限的，被使用后别的地方就无法使用。我们希望要用的时候向操作系统申请，不用的时候归还)如果某个资源使用了但不向操作系统说明该资源已不再使用。不使用，其他地方也用不了，这样就发生了资源泄漏</em></p>
<p>这样我们就经常在fially语句中释放这些非托管类型的资源</p>
<p>当程序正常运行时，程序的执行流程为：第（1）块 → 第（3）块</p>
<p>当第（1）块中有代码引发了一个异常时，程序的执行流程为：第（1）块 → 第（2）块 → 第（3）块</p>


<h4 class="relative group">一个异常实例：要求用户输入一个正整数： 
    <div id="%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E5%AE%9E%E4%BE%8B%E8%A6%81%E6%B1%82%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E5%AE%9E%E4%BE%8B%E8%A6%81%E6%B1%82%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>用户可能犯的错误有：</p>
<ul>
<li>未输入而直接敲回车</li>
<li>输入的字符串无法转换为数字</li>
<li>输入过大的数字</li>
<li>输入对特定场景无效的数字</li>
<li>输入负数、浮点数</li>
</ul>
<pre tabindex="0"><code>private static void InputNumber()
{
    Console.Write(&#34;请输入一个正整数：&#34;);
    try
    {
        //尝试着将用户输入的字符串转换为整数
        int value = Convert.ToInt32(Console.ReadLine());
        if (value &lt;= 0)
        {
            //发现非法的数据，“主动”抛出一个异常
            throw new InvalidOperationException(&#34;你输入的不是正整数！&#34;);
        }
        Console.WriteLine(&#34;您输入的数字是：{0}&#34;, value);
    }
    catch (FormatException)
    {
        Console.WriteLine(&#34;输入的字符串无法转换为数字&#34;);
    }
    catch (OverflowException)
    {
        Console.WriteLine(&#34;你输入的数字太大了！&#34;);
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }

    finally
    {
        Console.WriteLine(&#34;敲任意键退出……&#34;);
    }
}
</code></pre><ol>
<li>将可能出现异常的代码，封装到try语句块中</li>
<li>连续多个catch语句块，捕获并处理多种异常，利用了多态特性</li>
<li>不管程序运行时是否出现异步，finally块中的语句总会被执行</li>
</ol>
<p><em>多个catch语句块的时候，一般把较为特殊的异常放前面，从面向对象的角度看就是子类放前面基类放后面</em></p>


<h4 class="relative group">另一个异常的例子：数组越界 
    <div id="%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BE%8B%E5%AD%90%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BE%8B%E5%AD%90%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ExceptionInfo
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                int[] values = new int[10];
                for (int i = 1; i &lt;= 10; i++)
                    Console.WriteLine(values[i]);

            }
            catch (Exception e)
            {
                Console.WriteLine(&#34;在输出values数组值时发生数组越界错误&#34;);
                Console.WriteLine(&#34;异常种类:&#34; + e.GetType().Name);
                Console.WriteLine(&#34;系统给出的出错信息：&#34; + e.Message);
                Console.WriteLine(&#34;系统调用堆栈信息:&#34; + e.StackTrace);
                Console.WriteLine(&#34;引发此错误的方法：&#34; + e.TargetSite);
            }
            Console.ReadKey();
        }
    }
}
</code></pre>

<h4 class="relative group">.NET异常基类Exception的重要属性和方法 
    <div id="net%E5%BC%82%E5%B8%B8%E5%9F%BA%E7%B1%BBexception%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#net%E5%BC%82%E5%B8%B8%E5%9F%BA%E7%B1%BBexception%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>e.GetType()</td>
<td>获取异常的类型。</td>
</tr>
<tr>
<td>e.Message</td>
<td>告诉用户发生了什么事。</td>
</tr>
<tr>
<td>e.StackTrace</td>
<td>确定错误发生的位置，如果有可用的调试信息（即有&lt;程序名&gt;.pdb文件存在），还可显示源文件名和程序行号。</td>
</tr>
</tbody>
</table>
<p><em>注：上表中的e代表Exception对象</em></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.exception"   target="_blank">
    <strong>Exception</strong> 类 (System) | Microsoft Docs</a> 文档</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>条件</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.argumentexception?view=net-6.0"   target="_blank">
    ArgumentException</a></td>
<td>传递给方法的非 null 参数无效。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.argumentnullexception?view=net-6.0"   target="_blank">
    ArgumentNullException</a></td>
<td>传递给方法的参数为 <code>null</code>。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.argumentoutofrangeexception?view=net-6.0"   target="_blank">
    ArgumentOutOfRangeException</a></td>
<td>参数超出了有效值的范围。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.directorynotfoundexception?view=net-6.0"   target="_blank">
    DirectoryNotFoundException</a></td>
<td>目录路径的一部分无效。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.dividebyzeroexception?view=net-6.0"   target="_blank">
    DivideByZeroException</a></td>
<td>整数或 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.decimal?view=net-6.0"   target="_blank">
    Decimal</a> 除法运算中的分母为零。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.drivenotfoundexception?view=net-6.0"   target="_blank">
    DriveNotFoundException</a></td>
<td>驱动器不可用或不存在。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filenotfoundexception?view=net-6.0"   target="_blank">
    FileNotFoundException</a></td>
<td>文件不存在。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.formatexception?view=net-6.0"   target="_blank">
    FormatException</a></td>
<td>值的格式不适合通过转换方法（例如 <code>Parse</code>）从字符串转换。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.indexoutofrangeexception?view=net-6.0"   target="_blank">
    IndexOutOfRangeException</a></td>
<td>索引超出数组或集合的边界。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.invalidoperationexception?view=net-6.0"   target="_blank">
    InvalidOperationException</a></td>
<td>方法调用在对象的当前状态下无效。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.keynotfoundexception?view=net-6.0"   target="_blank">
    KeyNotFoundException</a></td>
<td>找不到用于访问集合中成员的指定键。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.notimplementedexception?view=net-6.0"   target="_blank">
    NotImplementedException</a></td>
<td>未实现方法或操作。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.notsupportedexception?view=net-6.0"   target="_blank">
    NotSupportedException</a></td>
<td>不支持方法或操作。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.objectdisposedexception?view=net-6.0"   target="_blank">
    ObjectDisposedException</a></td>
<td>对已释放的对象执行操作。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.overflowexception?view=net-6.0"   target="_blank">
    OverflowException</a></td>
<td>算术、强制转换或转换运算会导致溢出。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.pathtoolongexception?view=net-6.0"   target="_blank">
    PathTooLongException</a></td>
<td>路径或文件名超过系统定义的最大长度。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.platformnotsupportedexception?view=net-6.0"   target="_blank">
    PlatformNotSupportedException</a></td>
<td>当前平台上不支持该操作。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.rankexception?view=net-6.0"   target="_blank">
    RankException</a></td>
<td>向方法传递一个维度数量错误的数组。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.timeoutexception?view=net-6.0"   target="_blank">
    TimeoutException</a></td>
<td>分配给操作的时间间隔已过期。</td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.uriformatexception?view=net-6.0"   target="_blank">
    UriFormatException</a></td>
<td>使用了无效的统一资源标识符 (URI) 。</td>
</tr>
</tbody>
</table>


<h4 class="relative group">不要写鸵鸟式的代码 
    <div id="%E4%B8%8D%E8%A6%81%E5%86%99%E9%B8%B5%E9%B8%9F%E5%BC%8F%E7%9A%84%E4%BB%A3%E7%A0%81" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%8D%E8%A6%81%E5%86%99%E9%B8%B5%E9%B8%9F%E5%BC%8F%E7%9A%84%E4%BB%A3%E7%A0%81" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>static void Main(string[] args)
{
    try
    {
        //功能代码
    }
    catch(Exception ex)
    {
        //将会在此处“吃掉”所有的异常
        //不让操作系统弹出“程序错误”对话框
    }
}
</code></pre><p>异常的发生是件好事，它让程序员知道自己的程序可能存在着Bug，并且异常的出现还会通知用户有错误发生，他的数据有可能被破坏，从而让用户有机会考虑补救措施。这远比将所有“错误”包起来不让用户知道要理智得多。</p>


<h3 class="relative group">自定义异常与异常处理链 
    <div id="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%93%BE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%93%BE" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>自定义异常通常选择直接派生自Exception：</p>
<pre tabindex="0"><code>class MyException : Exception
{
    //...
}
</code></pre><p>在合适的地方使用throw语句抛出自定义异常对象：</p>
<pre tabindex="0"><code>class MyClass
{
    void someMethod()
    {
        if (条件) throw new MyException;
    }
}
</code></pre>

<h4 class="relative group">捕获并转换异常 
    <div id="%E6%8D%95%E8%8E%B7%E5%B9%B6%E8%BD%AC%E6%8D%A2%E5%BC%82%E5%B8%B8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%8D%95%E8%8E%B7%E5%B9%B6%E8%BD%AC%E6%8D%A2%E5%BC%82%E5%B8%B8" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>在实际开发中，经常需要将特定的“过于专业”的异常转换为一个“业务”异常，然后在调用者处进行捕获与处理。</p>
<pre tabindex="0"><code>程序从Main()方法开始运行……

throwExceptionMethod()方法开始执行
throwExceptionMethod()方法抛出了一个异常
throwExceptionMethod方法捕获并处理了抛出的Exception异常，并将其转换为一个自定义MyException异常再抛出
throwExceptionMethod()方法中的finally语句块执行结束

在Main()方法中捕获到MyException异常，其Message属性值为：在throwExceptionMethod()方法执行时出现MyException异常

doesNotThrowException()方法开始执行
doesNotThrowException()方法虽然包容try/catch/finally，但不会抛出任何异常
执行doesNotThrowException()方法中的finally语句块
doesNotThrowException()方法运行结束。


Main()方法运行结束，敲任意键退出……
</code></pre>

<h4 class="relative group">异常处理链 
    <div id="%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%93%BE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%93%BE" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ExceptionLinkInRealWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(&#34;程序从Main()方法开始运行……\n&#34;);

            try
            {
                throwExceptionMethod();  //有可能抛出异常的方法调用
            }
            catch (MyException e)
            {
                Console.WriteLine(&#34;在Main()方法中捕获到MyException异常，其Message属性值为：{0}&#34;,e.Message);

            }
            catch (Exception e)
            {
                Console.WriteLine(&#34;在Main()方法中捕获到Exception异常，其Message属性值为：{0}&#34;, e.Message);
            }
            doesNotThrowException(); //不抛出异常的方法调用
            Console.WriteLine(&#34;\nMain()方法运行结束，敲任意键退出……&#34;);
            Console.ReadKey();
        }
        /// 
        /// 自己虽然捕获了异常，但仍然希望外部进一步地处理，因此在简单地
        /// 捕获并处理老异常之后，再抛出一个新的异常供本方法的调用者进行捕获。
        /// 
        public static void throwExceptionMethod()
        {

            try
            {
                Console.WriteLine(&#34;throwExceptionMethod()方法开始执行&#34;);
                Console.WriteLine(&#34;throwExceptionMethod()方法抛出了一个异常&#34;);

                // 模拟产生一个异常
                throw new Exception(&#34;系统运行时引发的Exception异常&#34;);
            }
            catch (Exception e)
            {
                Console.WriteLine(&#34;throwExceptionMethod方法捕获并处理了抛出的Exception异常，并将其转换为一个自定义MyException异常再抛出&#34;, e);

                //转换为一个自定义异常，再抛出
                throw new MyException(&#34;在throwExceptionMethod()方法执行时出现MyException异常&#34;,e);


            }
            finally
            {
                Console.WriteLine(&#34;throwExceptionMethod()方法中的finally语句块执行结束\n&#34;);

            }
            try
            {
                //可能发生运行错误的代码块
            }
            catch
            {
                //用于处理异常的代码块
            }
            finally
            {
                //用于善后
            }


        }
        /// 
        /// 自己能完全处理异常，不需要外界参与
        /// 
        public static void doesNotThrowException()
        {
            try
            {
                Console.WriteLine(&#34;\ndoesNotThrowException()方法开始执行&#34;);
                Console.WriteLine(&#34;doesNotThrowException()方法虽然包容try/catch/finally，但不会抛出任何异常&#34;);


            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);

            }
            finally
            {
                Console.WriteLine(&#34;执行doesNotThrowException()方法中的finally语句块&#34;);

            }
            Console.WriteLine(&#34;doesNotThrowException()方法运行结束。\n&#34;);

        }
    }

    class MyException : Exception
    {
        public MyException(String Message) : base(Message)
        {
        }
        public MyException(string Message, Exception InnerException) : base(Message, InnerException)
        {

        }
    }
}
</code></pre><p>在实际开发中，可以参照ExceptionLinkInRealWorld示例的做法，定义一些与业务逻辑相关的自定义异常类，供上层代码进行捕获，从而能更精确地反映系统真实运行情况并及时进行处理。</p>
<p>在实际运行时，最底层的组件捕获一些异常，进行简单处理之后，可以将其转换为自定义的异常类型，再抛出供上层组件处理，而上层组件又可以重复这个工作，再把工作委托给再上层的组件处理……，由此即可构成一个“异常处理链”。</p>


<h3 class="relative group">嵌套的异常 
    <div id="%E5%B5%8C%E5%A5%97%E7%9A%84%E5%BC%82%E5%B8%B8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E5%BC%82%E5%B8%B8" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-87.png" alt="img" />
    
  </figure>

</p>
<p><strong>CLR采用两轮遍历的策略来处理多层嵌套的异常</strong></p>
<p>“扫描并查找相匹配的catch块”过程，是CLR异常处理流程的第一轮。</p>
<p>“扫描并查找相匹配的finally块”过程，是CLR处理异常流程的第二轮。</p>
<pre tabindex="0"><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

namespace EmbedException
{
    #region &#34;三个自定义异常类型&#34;
    class ExceptionA : Exception
    {

    }

    class ExceptionB : Exception
    {

    }

    class ExceptionC : Exception
    {

    }

    #endregion

    class Program
    {
        static void Main(string[] args)
        {

            try //Level1
            {
                Console.WriteLine(&#34;进入Level1的try语句块&#34;);
                try //Level2
                {
                    Console.WriteLine(&#34;进入Level2的try语句块&#34;);
                    //如果在Level3代码执行之前（和之后）出现异常，Level3的finally语句块还会执行吗？
                    //throw new ExceptionB();
                    try  //Level3
                    {
                        Console.WriteLine(&#34;进入Level3的try语句块&#34;);
                        //to do:每次抛出一种异常，注释掉其余的语句，然后观察输出结果
                        //throw new ExceptionA();
                        //throw new ExceptionB();
                         //throw new ExceptionC();
                        //throw new InvalidOperationException();
                        Console.WriteLine(&#34;退出Level3的try语句块&#34;);
                    }
                    catch (ExceptionA) //Level3
                    {
                        Console.WriteLine(&#34;在Level3中处理ExceptionA。&#34;);
                    }
                    finally //Level3
                    {
                        Console.WriteLine(&#34;Level3中的finally语句块&#34;);
                        WriteMessageToFile(&#34;Level3.txt&#34;, &#34;Level3中的finally语句块&#34;);
                    }

                    //throw new ExceptionB();
                    Console.WriteLine(&#34;退出Level2的try语句块&#34;);
                }
                catch (ExceptionB)
                {
                    Console.WriteLine(&#34;在Level2中处理ExceptionB&#34;);
                }
                finally
                {
                    Console.WriteLine(&#34;Level2中的finally语句块&#34;);
                    WriteMessageToFile(&#34;Level2.txt&#34;, &#34;Level2中的finally语句块&#34;);

                }
                Console.WriteLine(&#34;退出Level1的try语句块&#34;);
            }
            catch (ExceptionC)
            {
                Console.WriteLine(&#34;在Level1中处理ExceptionC &#34;);
            }
            //当示例抛出注释InvalidOperationException时，注释掉此块，查看CLR的异常处理策略
            catch (Exception)
            {
                Console.WriteLine(&#34;在Level1中处理Exception &#34;);
            }
            finally
            {
                Console.WriteLine(&#34;Level1中的finally语句块&#34;);
                WriteMessageToFile(&#34;Level1.txt&#34;, &#34;Level1中的finally语句块&#34;);
            }
            Console.ReadKey();//程序暂停
        }

        /// 
        /// 将异常信息写入到文件中，以备日后查询
        /// 
        /// 
        /// 
        private static void WriteMessageToFile(string FileName,string Message)
        {
            FileStream fs = new FileStream(FileName, FileMode.Create);
            StreamWriter sw = new StreamWriter(fs);
            sw.Write(Message);
            sw.Close();
            fs.Close();
        }


    }


}
</code></pre><p>如果在第三层内没有抛出任何异常：</p>
<pre tabindex="0"><code>进入Level1的try语句块
进入Level2的try语句块
进入Level3的try语句块
退出Level3的try语句块
Level3中的finally语句块
退出Level2的try语句块
Level2中的finally语句块
退出Level1的try语句块
Level1中的finally语句块
</code></pre><p>如果在第三层抛出 ExceptionA ：</p>
<pre tabindex="0"><code>进入Level1的try语句块
进入Level2的try语句块
进入Level3的try语句块
在Level3中处理ExceptionA。
Level3中的finally语句块
退出Level2的try语句块
Level2中的finally语句块
退出Level1的try语句块
Level1中的finally语句块
</code></pre><p>如果level3单抛出一个ExceptionB他将无法处理，他会先执行finally然后进入level2</p>
<pre tabindex="0"><code>进入Level1的try语句块
进入Level2的try语句块
进入Level3的try语句块
Level3中的finally语句块
在Level2中处理ExceptionB
Level2中的finally语句块
退出Level1的try语句块
Level1中的finally语句块
</code></pre><p>level3单抛出一个ExceptionC</p>
<pre tabindex="0"><code>进入Level1的try语句块
进入Level2的try语句块
进入Level3的try语句块
Level3中的finally语句块
Level2中的finally语句块
在Level1中处理ExceptionC
Level1中的finally语句块
</code></pre><p>如果抛出一个三层都无法处理的异常，如果没有加上</p>
<pre tabindex="0"><code>catch (Exception)
{
    Console.WriteLine(&#34;在Level1中处理Exception &#34;);
}
</code></pre><p>那么将会得到”未经处理的异常发生“，导致程序终止</p>
<p>如果在第二层try开头，在进入第三层之前抛出ExceptionB：</p>
<pre tabindex="0"><code>进入Level1的try语句块
进入Level2的try语句块
在Level2中处理ExceptionB
Level2中的finally语句块
退出Level1的try语句块
Level1中的finally语句块
</code></pre><p>可以看到根本就没有进入level3</p>
<p>如果在level3的try内尾部抛出ExceptionB，</p>
<pre tabindex="0"><code>进入Level1的try语句块
进入Level2的try语句块
进入Level3的try语句块
退出Level3的try语句块
Level3中的finally语句块
在Level2中处理ExceptionB
Level2中的finally语句块
退出Level1的try语句块
Level1中的finally语句块
</code></pre><p>所以在try内会跳过抛出异常后面的代码。</p>


<h4 class="relative group">把出错的异常信息写在文件/数据库内 
    <div id="%E6%8A%8A%E5%87%BA%E9%94%99%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E5%86%99%E5%9C%A8%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%8A%8A%E5%87%BA%E9%94%99%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E5%86%99%E5%9C%A8%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>/// 
/// 将异常信息写入到文件中，以备日后查询
/// 
/// 
/// 
private static void WriteMessageToFile(string FileName,string Message)
{
    FileStream fs = new FileStream(FileName, FileMode.Create);
    StreamWriter sw = new StreamWriter(fs);
    sw.Write(Message);
    sw.Close();
    fs.Close();
}
</code></pre><p>调用函数传入string FileName,string Message即可进行记录</p>
<p>调用实例：</p>
<pre tabindex="0"><code>WriteMessageToFile(&#34;level1.txt&#34;,&#34;level1语句块内&#34;);
WriteMessageToFile(&#34;level2.txt&#34;,&#34;level2语句块内&#34;);
WriteMessageToFile(&#34;level3.txt&#34;,&#34;level3语句块内&#34;);
WriteMessageToFile(&#34;level2.txt&#34;,&#34;level2的finally语句块&#34;);
WriteMessageToFile(&#34;level3.txt&#34;,&#34;level3的finally语句块&#34;);
</code></pre>

<h3 class="relative group">异常处理建议 
    <div id="%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%BB%BA%E8%AE%AE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%BB%BA%E8%AE%AE" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">实际开发中异常处理与捕获的“三个策略” 
    <div id="%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E6%8D%95%E8%8E%B7%E7%9A%84%E4%B8%89%E4%B8%AA%E7%AD%96%E7%95%A5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E6%8D%95%E8%8E%B7%E7%9A%84%E4%B8%89%E4%B8%AA%E7%AD%96%E7%95%A5" aria-label="锚点">#</a>
    </span>        
    
</h4>
<ol>
<li>预防所有可以预料和防止的错误；</li>
<li>处理所有可以预料但不能防止的错误；</li>
<li>捕获所有不能预料的错误；</li>
</ol>


<h4 class="relative group">实例：Windows XP中的资源管理器异常处理策略 
    <div id="%E5%AE%9E%E4%BE%8Bwindows-xp%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AE%9E%E4%BE%8Bwindows-xp%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>当复制文件时，如果目标驱动器空间不够，提示用户，并允许用户取消操作</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-88.png" alt="img" />
    
  </figure>

</p>
<p>这就是第一种情况——<strong>预防所有可以预料和防止的错误</strong>，当检测到这种错误时，程序可直接处理，无需专门引发一个异常。</p>
<p>用户在新建文件时不能与同一文件夹下的文件同名，如果用户这样做了，资源管理器给出了这样的提示</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-89.png" alt="img" />
    
  </figure>

</p>
<p>这就是第二种情况——<strong>处理所有可以预料但不能防止的错误</strong>。可以提供重试的机会，让用户按照正确的步骤与要求重做操作，在这种情况下也可以不用引发一个异常。</p>
<p>最后一种情况是无法预料的，比如正在向U盘复制文件过程中突然拔出U盘，这时，用户可以看到以下的提示：</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/05/image-90.png" alt="img" />
    
  </figure>

</p>
<p>这种<strong>无法预料</strong>的情况最适合于使用异常处理机制。</p>


<h4 class="relative group">关于开发中异常处理的具体建议 
    <div id="%E5%85%B3%E4%BA%8E%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%85%B7%E4%BD%93%E5%BB%BA%E8%AE%AE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%85%B3%E4%BA%8E%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%85%B7%E4%BD%93%E5%BB%BA%E8%AE%AE" aria-label="锚点">#</a>
    </span>        
    
</h4>
<ul>
<li>引发异常只是为了处理确实异常的情况，而不是为了处理可预知的事件或实现某种程序流程控制。</li>
<li>自身能够处理的异常，不要再向外界抛出。</li>
<li>尽可能地在靠近异常发生的地方捕获并处理异常。</li>
<li>在中间层组件中抛出异常，在界面层组件中捕获异常。</li>
<li>尽可能地捕获最具体的异常类型，不要在中间层用catch(Exception)“吃掉”所有异常</li>
<li>在底层组件中捕获CLR抛出的“只有程序员能看懂的”异常，转换为中间层的业务逻辑异常，再由界面层捕获以提供有意义的信息。</li>
<li>在开发阶段捕获并显示所有异常信息，发布阶段要移除部分代码，以避免“过于专业”的异常信息困扰用户，特别地，系统发布之后，不要将服务端异常的详细信息显示给客户端，以免被黑客利用。</li>
</ul>
<p>接下来是看不懂的</p>


<h3 class="relative group">C#7以上异常处理新特性 
    <div id="c7%E4%BB%A5%E4%B8%8A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B0%E7%89%B9%E6%80%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#c7%E4%BB%A5%E4%B8%8A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B0%E7%89%B9%E6%80%A7" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">throw 表达式 
    <div id="throw-%E8%A1%A8%E8%BE%BE%E5%BC%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#throw-%E8%A1%A8%E8%BE%BE%E5%BC%8F" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>public string Foo() =&gt; throw new NotImplementedException();

public MyRepository(IDatabase database)
{
    _database = database ??
                throw new ArgumentNullException(nameof(database));
}
</code></pre>

<h4 class="relative group">使用when子句构建异常过滤器 
    <div id="%E4%BD%BF%E7%94%A8when%E5%AD%90%E5%8F%A5%E6%9E%84%E5%BB%BA%E5%BC%82%E5%B8%B8%E8%BF%87%E6%BB%A4%E5%99%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BD%BF%E7%94%A8when%E5%AD%90%E5%8F%A5%E6%9E%84%E5%BB%BA%E5%BC%82%E5%B8%B8%E8%BF%87%E6%BB%A4%E5%99%A8" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>格式：</p>
<pre tabindex="0"><code>catch(Exception e) when(Condition)
{
    ...
}
try
{
    ...
}
catch( WebException e)
{
    if(e.Status != WebExceptionStatus.ConnectionFailure)
    {
        throw;
    }
    ...
}
try
{
    ...
}
catch( WebException e)
    when(e.Status == WebExceptionStatus.ConnectionFailure)
{
    ...
}
</code></pre>

<h2 class="relative group">泛型编程技术 
    <div id="%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">为什么使用泛型 
    <div id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>我们需要写个程序求出某数组元素中的最大值与最小值, 这个程序支持数字和字符串的处理</p>
<pre tabindex="0"><code>#region &#34;普通方法&#34;

    //在整数数组中查找最大最小值 
    private void GetMaxMinValueFromIntArray(int[] datas)
    {
        MaxInt = datas[0];
        MinInt = datas[0];
        for (int i= 1 ;i&lt;= IntArray.GetUpperBound(0);i++)
        {
            if (MaxInt &lt; datas[i]) 
                MaxInt = datas[i];
            if( MinInt &gt; datas[i]) 
                MinInt = datas[i];
        }
    } 

    //在字符数组中查找最大最小值
    private  void GetMaxMinValueFromCharArray(char [] datas  )
    {
        MaxChar = datas[0];
        MinChar = datas[0];
        for (int i  = 1;i&lt;= IntArray.GetUpperBound(0);i++)
        {
            if (MaxChar &lt; datas[i] )
                MaxChar = datas[i];
            if (MinChar &gt; datas[i] )
                MinChar = datas[i];
        }
    }

    private void OnButtonClick1()
{
        //填充数组
        FillArray();
        if (rdoInteger.Checked )
            GetMaxMinValueFromIntArray(IntArray);
        if (rdoChar.Checked )
            GetMaxMinValueFromCharArray(CharArray);
        //显示数据处理结果
        ShowResult();
    }

#endregion
</code></pre><p>示例程序中存在的问题：需要为不同类型的数组各提供一个代码类似的方法。</p>
<pre tabindex="0"><code>private void GetMaxMinValueFromIntArray( int[ ] datas)
private void GetMaxMinValueFromCharArray(char [ ] datas ) 
</code></pre><p>当增加一种新的类型时，需要再写一个类似的方法……</p>
<p>这些函数完成的工作都是一样的，不同之处仅仅在于处理的数据类型不一样，能否将这些非常类似的函数“合为一个”？</p>
<p><strong>定义泛型方法：</strong></p>
<pre tabindex="0"><code>private void GetMaxMinVauleFromArray(T[] datas ,ref T Max ,ref T Min) where T:IComparable
</code></pre><p>:泛型类型参数 where T:IComparable泛型类型约束(这个t必须实现IComparable接口)</p>
<p>方法参数前的ref关键字，表明方法将会修改传入变量的原始值，这就是说，方法执行完毕之后，传入的实参值将会被永久改变，方法调用语句后面的代码将得到一个被修改后的新值。</p>
<pre tabindex="0"><code>//使用时动态替换类型
GetMaxMinVauleFromArray(
    IntArray, ref MaxInt , ref MinInt);
GetMaxMinVauleFromArray(
    CharArray, ref MaxChar, ref MinChar);
</code></pre><p>经过修改的代码</p>
<pre tabindex="0"><code>#region &#34;泛型方法版本&#34;

    private void GetMaxMinVauleFromArray(T[] datas  ,
        ref T Max ,ref T Min) where T:IComparable 
    {
        Max = datas[0];
        Min = datas[0];
        for(int i  = 1 ;i&lt;=IntArray.GetUpperBound(0);i++)
        {
            if( Max.CompareTo(datas[i])&lt;0)
                Max = datas[i];
            if (Min.CompareTo(datas[i])&gt;0)
                Min = datas[i];
        }
    }

    private void OnButtonClick2()
    {
        //填充数组
        FillArray();
        //根据用户选项填充对应的数组
        if( rdoInteger.Checked )
            GetMaxMinVauleFromArray(IntArray, ref MaxInt,ref MinInt);

        if (rdoChar.Checked )
            GetMaxMinVauleFromArray(CharArray,ref MaxChar, ref MinChar);

      //显示数据处理结果
        ShowResult();
    }

#endregion
</code></pre>

<h3 class="relative group">泛型编程基础 
    <div id="%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">认识泛型编程 
    <div id="%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>当需要为 不同的数组各自提供代码类似的方法，如：</p>
<pre tabindex="0"><code>//分别在int和char数组中求出最大最小的值(char为ASC码)
private void GetMaxMinValueFromIntArray(int[] datas)
private void GetMaxMinValueFromCharArray(char[] datas)
</code></pre><p>即使处理的步骤是完全一样的，每个类型也都需要写一个类似的方法，为了把他们合并为一个方法，我们需要使用泛型：</p>
<p>将数据类型抽象出来变成&quot;T&quot;，这个T就是<strong>泛型类型参数</strong></p>
<pre tabindex="0"><code>private void GetMaxMinValueFromCharArray&lt;T&gt;(T[] datas, ref T Max, ref T Min)
    where T:IComparable
</code></pre><p>紧接着的是&quot;<strong>泛型类型约束</strong>&quot;，令这个类型必须实现IComparable接口，IComparable接口表明这个类型支持比较大小</p>
<p>方法参数前的ref关键字，表明方法将会修改传入变量的原始值。这意味着方法执行完毕时，传入的实参值将会被永久改变，方法调用语句后面的代码将得到一个被修改后的新值</p>


<h4 class="relative group">一个例子： 
    <div id="%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90" aria-label="锚点">#</a>
    </span>        
    
</h4>


<h4 class="relative group">泛型类的编写方法 
    <div id="%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E7%BC%96%E5%86%99%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E7%BC%96%E5%86%99%E6%96%B9%E6%B3%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>只需给类指定一个（或多个）“类型参数（Type parameter）”，然后， 将原先具体的数据类型用定义的类型参数（Type arguments）替换即可</p>
<pre tabindex="0"><code>public class GenericList
{
    void Add(T input) { }
} 
</code></pre><p>GetMaxMinVaulC#中的泛型特性，是在 2.0引入的（2005年），当时引发了很大的关注， 因为.NET的泛型是“真泛型”，由CLR直接支持，而同期Java的泛型 （JDK 1.5）是“假”的，因为JVM并不提供支持，全靠Java编译器的 “类型擦除”魔法实现。</p>


<h4 class="relative group">设定泛型类型参数的约束 
    <div id="%E8%AE%BE%E5%AE%9A%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E7%BA%A6%E6%9D%9F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%AE%BE%E5%AE%9A%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E7%BA%A6%E6%9D%9F" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>如果希望限制泛型类所能适用的数据类型，可以给类型参数添加约束</p>
<pre tabindex="0"><code>class MyClass
    where T:struct
    where U:IComparable,new()
{
    T value;
    void fun(U obj)
    {
    }
}
</code></pre><p><strong>类型参数的约束</strong>：</p>
<ol>
<li>类型T必须为值类型</li>
<li>类型U必须实现IComparable接口并且必须具有一个无参数的构造函数</li>
</ol>
<p>几种常用的泛型参数约束</p>
<table>
<thead>
<tr>
<th>T：struct</th>
<th>类型参数必须是值类型。可以指定除 以外的任何值 类型。</th>
</tr>
</thead>
<tbody>
<tr>
<td>T：class</td>
<td>类型参数必须是引用类型；这一点也适用于任何类、接口、委托或数组类型。</td>
</tr>
<tr>
<td>T：new</td>
<td>类型参数必须具有无参数的公共构造函数。当与其 他约束一起使用时，new() 约束必须最后指定。</td>
</tr>
<tr>
<td>T：&lt;基类名&gt;</td>
<td>类型参数必须是指定的基类或派生自指定的基类。</td>
</tr>
<tr>
<td>T：&lt;接口名称&gt;</td>
<td>类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。</td>
</tr>
</tbody>
</table>


<h4 class="relative group">泛型类与泛型方法的示例 
    <div id="%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E7%A4%BA%E4%BE%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E7%A4%BA%E4%BE%8B" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>当类中的某个方法使用了类型参数，这种方法称为“<strong>泛型方法</strong>”。</p>
<p>泛型方法多出现在泛型类中，但在普通的类中也可以直接定义泛型方法：</p>
<pre tabindex="0"><code>class MyClass
{
    static void Swap&lt;T&gt;(ref T lhs, ref T rhs)
    {
        T temp;
        temp = lhs;
        lhs = rhs;
        rhs = temp;
    }
}
</code></pre>

<h3 class="relative group">泛型编程小结 
    <div id="%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%BB%93" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%BB%93" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>泛型编程的好处：</p>
<ul>
<li>减少类的数目，结构与功能高度类似的类可以被&quot;合并&quot;为一个</li>
<li>剥离数据结构与算法，可以编写一些&quot;通用&quot;的算法，这些算法可以应用于多种数据类型</li>
<li>减少编码错误，可以在编译期间通过检查数据类型而发现许多编码错误，可以在编程时直接 使用集成开发环境提供的的下拉列表功能</li>
<li>提升程序运行效率，减少装箱和拆箱以及数据类型转换等操作带来的损失</li>
</ul>


<h2 class="relative group">C#面向对象编程进阶篇 
    <div id="c%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%E7%AF%87" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#c%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%E7%AF%87" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h2 class="relative group">对象组合 
    <div id="%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88" aria-label="锚点">#</a>
    </span>        
    
</h2>
<p>在面向对象成为主流软件开发方式的的时代中，一个软件在运行过程中会创建多个对象，对象之间有着比较复杂的合作关系，他们之间相互协作，共同完成软件的各种 功能。</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/08/image.png" alt="img" />
    
  </figure>

</p>
<p>&ldquo;对象组合&quot;是对象合作关系中的一种，其含义是&quot;一个对象包容另一个对象&rdquo;</p>


<h3 class="relative group">两种典型的对象组合方式： 
    <div id="%E4%B8%A4%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%E6%96%B9%E5%BC%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%A4%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%E6%96%B9%E5%BC%8F" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/08/image-1.png" alt="img" />
    
  </figure>

</p>
<p>方式一：A对象完全包容B对象，容器对象 管理 被包容对象 的从生到死，即“对象的生命周期”</p>
<p>




  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://imgs2023.oss-cn-shanghai.aliyuncs.com/2022/08/image-2.png" alt="img" />
    
  </figure>

</p>
<p>方式二：A和B对象是相互独立的关，A对象引用现成的B对象，两者之间是一种比较松散的协作关系</p>

        </div>
        
        

        
        

          
      </div>
     
      
      
        
        
          
          
        
      <script>
        var oid = "views_posts\\金旭亮C#编程课个人自学笔记.md"
        var oid_likes = "likes_posts\\金旭亮C#编程课个人自学笔记.md"
      </script>
      
      
      
      <script type="text/javascript" src="/about/js/page.min.b06a29d42a4ed16787978e2eee1e8c797b7698db2bc14ccee78f5c80ac566fc996190a73ad80a5e987558474b20b96fa38f7d85b405f165ff72b7b163c5ad11b.js" integrity="sha512-sGop1CpO0WeHl44u7h6MeXt2mNsrwUzO549cgKxWb8mWGQpzrYCl6YdVhHSyC5b6OPfYW0BfFl/3K3sWPFrRGw=="></script>
  
    </section>
  <footer class="pt-8 max-w-prose print:hidden">

    
  
    
    
    
    <div class="pt-8">
      <hr class="border-dotted border-neutral-300 dark:border-neutral-600" />
      <div class="flex justify-between pt-3">
        <span>
          
            <a class="flex group mr-3" href="/about/posts/%E9%87%91%E6%97%AD%E4%BA%AEc%23%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%E8%BF%9B%E9%98%B6%E7%AF%87/">
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  ></span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="0001-01-01 00:00:00 &#43;0000 UTC">0001 January 1</time>
                  
                </span>
              </span>
            </a>
          
        </span>
        <span>
          
            <a class="flex text-right group ml-3" href="/about/posts/unity%E8%A7%A3%E5%8C%85/">
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >unity解包</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2023-08-14 00:00:00 &#43;0000 UTC">2023 August 14</time>
                  
                </span>
              </span>
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
            </a>
          
        </span>
      </div>
    </div>
  


    
  </footer>
</article>

      <div id="top-scroller" class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0">
  <a href="#the-top"
    class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400"
    aria-label="返回顶部" title="返回顶部">
    &uarr;
  </a>
</div>
    </main><footer id="site-footer" class="py-10 print:hidden">
  
  
    
    <nav class="flex flex-row pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400">
      <ul class="flex flex-col list-none sm:flex-row">
        
        <li class="flex mb-1 ltr:text-right rtl:text-left sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0">
          <a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href="/about/tags/"
            title="">
            
            标签
          </a>
        </li>
        
      </ul>
    </nav>
    
  
  <div class="flex items-center justify-between">

    
    
    <p class="text-sm text-neutral-500 dark:text-neutral-400">
      &copy;
      2024
      Kumo67
    </p>
    

    
    
    <p class="text-xs text-neutral-500 dark:text-neutral-400">
      
      
      由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> &amp; <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://blowfish.page/" target="_blank" rel="noopener noreferrer">Blowfish</a> 强力驱动
    </p>
    

  </div>
  <script>
    
    mediumZoom(document.querySelectorAll("img:not(.nozoom)"), {
      margin: 24,
      background: 'rgba(0,0,0,0.5)',
      scrollOffset: 0,
    })
    
  </script>
  
  
  <script type="text/javascript" src="/about/js/process.min.62060bb247f4de2b6dde45903668fefb68d792f365587605177b1227c0cf43588701edaca0cb40e2c8e2789bd5ce67c1d2a215b9fb258c3496a7cd25e7cb5fdf.js" integrity="sha512-YgYLskf03itt3kWQNmj&#43;&#43;2jXkvNlWHYFF3sSJ8DPQ1iHAe2soMtA4sjieJvVzmfB0qIVufsljDSWp80l58tf3w=="></script>
  
  
</footer><div
  id="search-wrapper"
  class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]"
  data-url="http://localhost:1313/about/"
  style="z-index:500"
>
  <div
    id="search-modal"
    class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"
  >
    <header class="relative z-10 flex items-center justify-between flex-none px-2">
      <form class="flex items-center flex-auto min-w-0">
        <div class="flex items-center justify-center w-8 h-8 text-neutral-400">
          

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


        </div>
        <input
          type="search"
          id="search-query"
          class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent"
          placeholder="搜索"
          tabindex="0"
        />
      </form>
      <button
        id="close-search-button"
        class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        title="关闭 (Esc)"
      >
        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>


      </button>
    </header>
    <section class="flex-auto px-2 overflow-auto">
      <ul id="search-results">
        
      </ul>
    </section>
  </div>
</div>

  </div>
</body>

</html>
